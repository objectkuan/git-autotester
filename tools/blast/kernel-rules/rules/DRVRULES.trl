<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="DRVRULES.xsl"?>
<КОРЕНЬ item="y" tlversion="1.2.3"
line0="LINUX DRIVERS RULES"
line1="&lt;b&gt;LINUX DRIVERS RULES&lt;/b&gt;">
<Имя type="Text" ref="y">Корень</Имя>
<ЛЕГЕНДА item="y"
line0="{*Имя*}"
line1="{*Текст*}">
<Имя type="Text" ref="y">ЛЕГЕНДА</Имя>
<Текст type="Text" html="y">ВЕРИФИКАЦИОННЫЕ ТИПЫ:
&lt;div&gt;
&lt;b&gt;ПА&lt;/b&gt; - Поддержка атрибутов gcc
&lt;/div&gt;
&lt;div&gt;
&lt;b&gt;ДВ&lt;/b&gt; - Статический анализ выполнения (динамическая верификация)
&lt;/div&gt;
&lt;div&gt;
&lt;b&gt;ПС&lt;/b&gt; - Поддержка синтаксиса
&lt;/div&gt;
&lt;div&gt;
&lt;b&gt;РС&lt;/b&gt; - Расширенные статические проверки
&lt;/div&gt;</Текст>
</ЛЕГЕНДА>
<ГРУППА item="y"
line0="{*Имя*}"
line1="&lt;b&gt;{*Имя*}&lt;/b&gt;">
<Имя type="Text" ref="y">GENERAL MODULES</Имя>
<ПРАВИЛО_ERROR item="y"
line0="{*ID*}"
line1="&lt;table border=&quot;1&quot;&gt;"
line2="&lt;tr&gt;&lt;td&gt;"
line3="&lt;b&gt;&lt;font color=&quot;red&quot;&gt;{*ТИП*}&lt;/font&gt;&lt;/b&gt;"
line4="&lt;/td&gt;&lt;/tr&gt;"
line5="&lt;tr&gt;&lt;td&gt;"
line6="&lt;b&gt;{*ID*}: {*Имя*}&lt;/b&gt;"
line7="&lt;/td&gt;&lt;/tr&gt;"
line8="&lt;tr&gt;&lt;td&gt;"
line9="&lt;b&gt;НАЗНАЧЕНИЕ:&lt;/b&gt;"
line10="{*НАЗНАЧЕНИЕ*}"
line11="&lt;/td&gt;&lt;/tr&gt;"
line12="&lt;tr&gt;&lt;td&gt;"
line13="&lt;b&gt;ПРИМЕР:&lt;/b&gt;"
line14="{*ПРИМЕР*}"
line15="&lt;/td&gt;&lt;/tr&gt;"
line16="&lt;tr&gt;&lt;td&gt;"
line17="&lt;b&gt;ВЕРИФИКАЦИЯ&lt;/b&gt;"
line18="{*ВЕРИФИКАЦИЯ*}"
line19="&lt;/td&gt;&lt;/tr&gt;"
line20="&lt;tr&gt;&lt;td&gt;"
line21="&lt;b&gt;ТИП ВЕРИФИКАЦИИ&lt;/b&gt;"
line22="{*ВЕРТИП*}"
line23="&lt;/td&gt;&lt;/tr&gt;"
line24="&lt;tr&gt;&lt;td&gt;"
line25="&lt;b&gt;ПРИМЕЧАНИЯ&lt;/b&gt;"
line26="{*ПРИМЕЧАНИЯ*}"
line27="&lt;/td&gt;&lt;/tr&gt;"
line28="&lt;tr&gt;&lt;td&gt;"
line29="&lt;b&gt;СОСТОЯНИЕ&lt;/b&gt;"
line30="{*СОСТОЯНИЕ*}"
line31="&lt;/td&gt;&lt;/tr&gt;"
line32="&lt;tr&gt;&lt;td&gt;"
line33="&lt;b&gt;ХАРАКТЕРИСТИКА&lt;/b&gt;"
line34="{*ХАРАКТЕРИСТИКА*}"
line35="&lt;/td&gt;&lt;/tr&gt;"
line36="&lt;/table&gt;"
generic="ПРАВИЛО"
icon="bullet_1">
<Имя type="Text" ref="y">Использование user-space данных в модулях ядра.
Выдача предупреждения в случае отсутствия требуемых атрибутов параметров.</Имя>
<ID type="Text" prefix="ID ">0001</ID>
<НАЗНАЧЕНИЕ type="Text">Исключить возможные ошибки при работе с указателями на буфер данных user-space из модуля ядра (драйвера).
Такого рода проблемы часто возникают при работе с интерфейсами обеспечения передачи информации между пользовательской файловой системой и разрабатываемым модулем (описание данного рода интерфейсов приведено в заголовочном файле fs.h)</НАЗНАЧЕНИЕ>
<ТИП type="Combination" format="ERROR1/ERROR2/ERROR3" html="y">ERROR3</ТИП>
<ПРИМЕР type="Text">static ssize_t dev_read(struct file * file,char * __user buf, size_t size,loff_t offset)
{
	copy_to_user(buf,msg,strlen(msg));
	return strlen(msg);
}
Данный код осуществляет реализацию интерфейса чтения для объекта символьного устройства Linux. Данные копируются в пользовательский буфер с помощью системной функции copy_to_user(), которая инкапсулирует множественные вызовы put_user(), осуществляющей побайтовое копирование с учетом базового адреса сегмента пользовательского процесса.</ПРИМЕР>
<ВЕРИФИКАЦИЯ type="Text">При обнаружении входных параметров, помеченных с помощью атрибута __user требуется запретить прямое использование данных переменных в качестве параметров стандартных функций форматирования (например, sprintf) так как это приведет к ошибке адресации.
С данными указателями можно работать только с помощью copy_to_user, copy_from_user.</ВЕРИФИКАЦИЯ>
<ВЕРТИП type="Text">ПА</ВЕРТИП>
<ПРИМЕЧАНИЯ type="Text"></ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ type="Text"></СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА type="Text">АТРИБУТЫ:ПЕРЕМЕННЫЕ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y"
line0="{*ID*}"
line1="&lt;table border=&quot;1&quot;&gt;"
line2="&lt;tr&gt;&lt;td&gt;"
line3="&lt;b&gt;&lt;font color=&quot;orange&quot;&gt;{*ТИП*}&lt;/font&gt;&lt;/b&gt;"
line4="&lt;/td&gt;&lt;/tr&gt;"
line5="&lt;tr&gt;&lt;td&gt;"
line6="&lt;b&gt;{*ID*}: {*Имя*}&lt;/b&gt;"
line7="&lt;/td&gt;&lt;/tr&gt;"
line8="&lt;tr&gt;&lt;td&gt;"
line9="&lt;b&gt;НАЗНАЧЕНИЕ:&lt;/b&gt;"
line10="{*НАЗНАЧЕНИЕ*}"
line11="&lt;/td&gt;&lt;/tr&gt;"
line12="&lt;tr&gt;&lt;td&gt;"
line13="&lt;b&gt;ПРИМЕР:&lt;/b&gt;"
line14="{*ПРИМЕР*}"
line15="&lt;/td&gt;&lt;/tr&gt;"
line16="&lt;tr&gt;&lt;td&gt;"
line17="&lt;b&gt;ВЕРИФИКАЦИЯ&lt;/b&gt;"
line18="{*ВЕРИФИКАЦИЯ*}"
line19="&lt;/td&gt;&lt;/tr&gt;"
line20="&lt;tr&gt;&lt;td&gt;"
line21="&lt;b&gt;ТИП ВЕРИФИКАЦИИ&lt;/b&gt;"
line22="{*ВЕРТИП*}"
line23="&lt;/td&gt;&lt;/tr&gt;"
line24="&lt;tr&gt;&lt;td&gt;"
line25="&lt;b&gt;ПРИМЕЧАНИЯ&lt;/b&gt;"
line26="{*ПРИМЕЧАНИЯ*}"
line27="&lt;/td&gt;&lt;/tr&gt;"
line28="&lt;tr&gt;&lt;td&gt;"
line29="&lt;b&gt;ХАРАКТЕРИСТИКА&lt;/b&gt;"
line30="{*ХАРАКТЕРИСТИКА*}"
line31="&lt;/td&gt;&lt;/tr&gt;"
line32="&lt;/table&gt;"
generic="ПРАВИЛО"
icon="bullet_2">
<Имя type="Text" ref="y">Использование специализированных атрибутов для параметров интерфейсов взаимодействия с пространством пользователя</Имя>
<ID type="Text" prefix="ID ">0002</ID>
<НАЗНАЧЕНИЕ type="Text">Упрощение процедуры верификации ошибки ID 0001
Повышение читабельности кода и упрощение его отладки</НАЗНАЧЕНИЕ>
<ТИП type="Combination" format="WARNING1/WARNING2/WARNING3" html="y">WARNING1</ТИП>
<ПРИМЕР type="Text">static ssize_t dev_read(struct file * file,char * __user buf, size_t size,loff_t offset)
Параметр buf, имеющий тип char* хранит адрес буфера в адресном пространстве пользовательского процесса, поэтому его прямое использование функциями ввода-вывода модуля ядра недопустимо.</ПРИМЕР>
<ВЕРИФИКАЦИЯ type="Text">Сопоставление верифицируемого кода с прототипами функций интерфейсов с user-space приложениями (например, из заголовочно файла fs.h)
Выдача предупреждения в случае отсутствия требуемых атрибутов параметров.</ВЕРИФИКАЦИЯ>
<ВЕРТИП type="Text">ПА</ВЕРТИП>
<ПРИМЕЧАНИЯ type="Text"></ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ type="Text"></СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА type="Text">АТРИБУТЫ:ПЕРЕМЕННЫЕ
КОНТЕКСТ:CALLBACK
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование специализированных атрибутов для функций начальной инициализации модуля и финализации модуля</Имя>
<ID>0003</ID>
<НАЗНАЧЕНИЕ>При использовании драйвера устройства в качестве статической части ядра (а не подключаемого модуля) существует возможность оптимизации системных ресурсов. Во-первых, за счет высвобождения памяти, занимаемой функцией инициализации (init) после активации ядра. А во-вторых, за счет не использования памяти для функции финализации (exit) (так как выгрузка памяти ядра происходит только при останове системы)</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>static int __init start_module() { ... }
static void __exit stop_module() { ... }
module_init(start_module);
module_exit(stop_module);

&quot;Рекомендованный отказ от устаревшего интерфейса
инициализации/деактивации модулей ядра
и переход на module_init()/module_exit() механизм&quot;
ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/net/ac3200.c
2.6.25 -&gt; drivers/net/apne.c
2.6.25 -&gt; drivers/net/arcnet/capmode.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Получение идентификаторов (имен) функций, передаваемых макросам module_init(...) и module_exit(...) и дальнейшая проверка наличия у их прототипов атрибутов и __init и __exit соответственно</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ПА</ВЕРТИП>
<ХАРАКТЕРИСТИКА>АТРИБУТЫ:ФУНКЦИИ
КОНТЕКСТ:CALLBACK
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование специализированных атрибутов для данных, используемых исключительно функциями начальной инициализации модуля</Имя>
<ID>0004</ID>
<НАЗНАЧЕНИЕ>Обеспечение возможности оптимизации системных ресурсов за счет выгрузки данных, обладающих атрибутом &quot;используются только процедурой начальной инициализации&quot; (__initdata) после активации модуля</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>static int __initdata var;
static char __initdata str[]=&quot;string&quot;;</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Получение идентификаторов данных, используемых исключительно в функциях инициализации (идентификатор базовой функции инициализации передается макросу module_init(), также следует учитывать все вложенные функции) и их дальнейшая проверка на наличие атрибута __initdata</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ПА</ВЕРТИП>
<ХАРАКТЕРИСТИКА>АТРИБУТЫ:ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Возвращение неожиданных значений callback-функциями драйвера</Имя>
<ID>0007</ID>
<НАЗНАЧЕНИЕ>Исключить возможность возврата неожиданных значений в вызывающую системную процедуру, которая может трактовать такой результат, как внутреннюю ошибку. В этом случае часто происходит отображение сообщений &quot;Oops&quot; ядром операционной системы.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>static int usb_device_open(struct inode *inode, struct file *file) {
        int retval = 0;
        ...
        retval = usb_device_init();
        if ( retval &lt; 0)
                info(&quot;Failed initialization&quot;);
        ...
        return retval;
}

Вызывающая процедура операционной системы ожидает получения нулевого результата в случае успешного завершения callback-метода; в данном же случае возможен возврат положительного значения, что будет трактоваться ОС как ошибка отработки функции драйвера, хотя на самом деле, ее выполнение было успешным.
Требуется обеспечить контроль за возвращаемым значением с помощью дополнительных условий:
static int usb_device_open(struct inode *inode, struct file *file) {
        int retval = 0;
        ...
// some initialization
        retval = usb_device_init();
        if ( retval &lt; 0)
                info(&quot;Failed initialization&quot;);
        ...
// failed
        if ( retval &lt; 0)
                return retval;
// success
        else
                return 0;
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется ввести запрет на прямой возврат значений, полученных путем вызова процедур, которые потенциально могут вернуть значения не лежащие в диапазоне [-n,0], где n - наибольшая величина, описанная как допустимый код возврата в случае ошибки.
Значения кодов возврата содержатся в заголовочных файлах ядра (include/linux/errno.h).</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Где найти описание usb_device_init?
Требуется найти функции, которые могут возвращать положительные значения и которые могут вызываться в обработчиках (open...). Желательно с примерами драйверов.
Код проверки:
  result = device-&gt;open(port,filp);
  assert(result&lt;=0);

usb_device_init it's only example code. Its not a real kernel function.

Real driver code example is present here:

$KERNEL_SOURCE/drivers/char/toshiba.c
Some code sample of callback function ioctl:
...
static int tosh_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
	unsigned long arg)
{
	SMMRegisters regs;
	SMMRegisters __user *argp = (SMMRegisters __user *)arg;
	unsigned short ax,bx;
	int err;

	if (!argp)
		return -EINVAL;

	if (copy_from_user(&amp;regs, argp, sizeof(SMMRegisters)))
		return -EFAULT;

	switch (cmd) {
		case TOSH_SMM:
			ax = regs.eax &amp; 0xff00;
			bx = regs.ebx &amp; 0xffff;
			/* block HCI calls to read/write memory &amp; PCI devices */
			if (((ax==0xff00) || (ax==0xfe00)) &amp;&amp; (bx&gt;0x0069))
				return -EINVAL;

			/* do we need to emulate the fan ? */
			if (tosh_fan==1) {
				if (((ax==0xf300) || (ax==0xf400)) &amp;&amp; (bx==0x0004)) {
					err = tosh_emulate_fan(&amp;regs);
					break;
				}
			}
			err = tosh_smm(&amp;regs);
			break;
		default:
			return -EINVAL;
	}

        if (copy_to_user(argp, &amp;regs, sizeof(SMMRegisters)))
        	return -EFAULT;

//!!!RETURN CODE ERROR CHECKING
	return (err==0) ? 0:-EINVAL;
}

...</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>COMPLETED, EXAMPLE_DONE</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:CALLBACK
ПЕРЕМЕННЫЕ:ЗНАЧЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Нахождение модуля ядра (драйвера) в состоянии &quot;недоступен для выгрузки&quot; постоянно или без необходимости.</Имя>
<ID>0008</ID>
<НАЗНАЧЕНИЕ>Исключить возможность полной блокировки выгрузки драйвера без объективных причин (использование какими-либо объектами ОС или пользовательскими процессами).
Возможность блокировки драйвера делает его использование драйвера, а в некоторых случаях оказывает влияние на стабильность и возможность работы системы в целом.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>static int dev_open(struct inode*, struct file*)
{
try_module_get(THIS_MODULE);
...
//отсутствие вызова module_put(THIS_MODULE) для уменьшения значения счетчика-семафора возможности выгрузки модуля
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется обеспечить вызов необходимой процедуры/макроса освобождения семафора блокировки выгрузки если ранее процедура осуществляла его установку (увеличение).
Обычно вызов процедур/макросов try_module_get(...) и module_put(...) осуществляется в одном функциональном блоке, поэтому проверку всех вложенных функций можно исключить.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>отсутствие вызова module_put(THIS_MODULE)  в open?

Not only in open function...We should control some &quot;closed&quot; blocks of try_module_get() / module_put in all our code</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:CALLBACK
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Осуществление запросов к функциям низкоуровневого выделения памяти для запроса блока по размеру не кратного размеру страницы виртуальной памяти.</Имя>
<ID>0009</ID>
<НАЗНАЧЕНИЕ>Исключить возможные ошибки низкоуровневых функций, в которых отсутствует проверка на допустимость входных параметров (для повышения производительности) или используются алгоритмы, изначально рассчитанные для работы с величинами кратными размеру страницы ВП.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>Использование низкоуровневой функции выделения памяти __get_free_pages:
static inline void *mem_alloc(size_t size) {
        void *mem;
        mem = (void *)__get_free_pages(GFP_ATOMIC, get_order((PAGE_ALIGN(size)));
//Обязательно использование макроса PAGE_ALIGN для приведения значения размера выделяемого блока к числу, кратному размеру страницы
        ...
        return mem;
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Проверять обязательное использование макроса PAGE_ALIGN(...) при передаче размера блока в низкоуровневые функции выделения памяти.
Обычно, макрос используется непосредственно при передаче параметров в функцию (см. пример), поэтому достаточно проверять только набор лексем, отвечающий за вызов функции.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Замена get_order:
int get_order(unsigned long size) {
assert(size == PAGE_ALIGN(size))
}
Можно ли наложить ограничения на order, который передается в __get_free_pages?

I'll think about this :)

get_order: located in asm-i386/page.h
static __inline__ int get_order(unsigned long size)

Во многих драйверах применяется также механизм макроса прямого битового выравнивания через get_order():
/s390/char/tty3270.c
/scsi/53c7xx.c
/scsi/ncr53c8xx.c

Также постараюсь проанализировать некоторые дополнительные макроподстановки из, например, /net/82596.c

На примере floppy.c Blast не завершился за 33 минуты.</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_PREPARED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование флага GFP_ATOMIC в функции выделения памяти kmalloc(...) в контексте прерывания.</Имя>
<ID>0010</ID>
<НАЗНАЧЕНИЕ>При вызове функции выделения памяти из контекста прерывания, требуется обеспечить &quot;невытесняемую&quot; работу данной функции; в то время, как в случае указания флага GFP_KERNEL выполнение функции может быть временно приостановлено т.к. осуществляется более широкий ряд операций по поиску и выделению блоков памяти.</НАЗНАЧЕНИЕ>
<ТИП>ERROR2</ТИП>
<ПРИМЕР>void* ptr = kmalloc(size,GFP_ATOMIC);</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Если определенная функция драйвера позиционируется как &quot;работающая в контексте прерывания&quot;, то требуется осуществлять проверку на необходимое использование флага GFP_ATOMIC в функциях выделения памяти, предназначенных для модулей ядра.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Пусть f - обработчик прерывания.
Окружение устанавливает флаг IN_INT (наш собственный), затем вызывает f.
Заменяем kmalloc(s,gfp) на
assert(!IN_INT || (gfp==GFP_ATOMIC))

Автоматическими средствами выявил драйверы, использующие этот распространенный механизм. Некоторые используют напрямую, другие - используют более низкоуровневое обращение к __get_free_pages():

вырезано.

Привязка к прерываниям request_irq, release_irq</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_REJECTED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ФЛАГИ УПРАВЛЕНИЯ
КОНТЕКСТ:ПРЕРЫВАНИЕ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ
КАТЕГОРИЯ:ПРЕРЫВАНИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Отсутствие задержек между записями данных в порты ввода-вывода.</Имя>
<ID>0011</ID>
<НАЗНАЧЕНИЕ>Исключить возможные ошибки, связанные с запаздыванием установки реальных значений портов ввода-вывода, из-за особенностей взаимодействия операционной системы и платформы.
Рекомендуется использовать в групповых инструкциях установки/получения значений портов ввода-вывода вместо процедур/макросов inb(...)/outb(...) специализированные процедуры/макросы inb_p(...)/outb_p(...), которые обеспечивают требуемую задержку, достаточную для установки требуемых значений.</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>outb_p(0 , PORT1 + 1);
outb_p(0x80 , PORT1 + 3);
outb_p(0x02 , PORT1 + 0);
outb_p(0x03 , PORT1 + 3);
Данный фрагмент может вызывать проблемы, связанные с задержками установки значений портов. Следовательно, возможна ошибка формата протокола взаимодействия с устройством. Рекомендуется использование функций, осуществляющих дополнительную задержку.</ПРИМЕР>
<ВЕРИФИКАЦИЯ>При обнаружении последовательного множественного вызова функций работы с портами ввода-вывода осуществлять оповещение  о требовании использования функций inb_p/outb_p и т.п.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<ПРИМЕЧАНИЯ>между двумя последовательными outb требуется выполнение хотя бы одной инструкции

And we should recommend to use inb_p/outb_p func</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВРЕМЕНЕМ ЗАДЕРЖКИ
КАТЕГОРИЯ:I/O</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_WARNING item="y">
<Имя>Получение доступа к объекту файловой системы (использование функций open/close/read/write)</Имя>
<ID>0012</ID>
<НАЗНАЧЕНИЕ>Исключить возможность ошибочного завершения модуля, связанного с отсутствием требуемого файла в текущем корневом каталоге (или по заданному относительному или абсолютному пути). Причина такого поведения заключается в неопределенном корневом каталоге модуля (это может быть как корневой каталог пространства init в случае загрузки модуля при старте ядра, так и корневой каталог пользователя root (который может быть изменен командой chroot) при динамической загрузке модуля).</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
int fd;
if((fd=open(CONFIG_FILE_PATH,O_RDWR,0))!=-1)
{
...
}
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется запретить использование системного вызова open(...) внутри функций, реализуемых модулем ядра.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Если не учитывать dead code, то можно ограничиться РС
ДВ:
заменяем open()
assert(0);//нельзя вызывать</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_WARNING item="y">
<Имя>Принятие решения в зависимости от имени текущего прерваного пользовательского процесса</Имя>
<ID>0013</ID>
<НАЗНАЧЕНИЕ>Исключить возможные ошибки функционирования модуля, связанные с неверным определением прерванного процесса. Это может быть вызвано возможным существованием процесса с таким же именем как и требуемый или преднамеренной подменой с целью воздействия на модуль и ядро в целом.</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
if(!strcmp(current-&gt;comm,&quot;smb&quot;))
{
...
}
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Предупреждать об использовании указателя current-&gt;comm в операциях сравнения строк в функциях модуля.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Неявное использование арифметических операций с плавающей точкой.</Имя>
<ID>0016</ID>
<НАЗНАЧЕНИЕ>Исключить неявные операции с плавающей точкой, которые запрещены как для компонентов ядра, так и для динамически загружаемых модулей.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>Заголовочный файл:
...
#define NTSC 14.31818
#define calc_freq(n,m,k) ((NTSC * (n+8))/((m+2)*(1&lt;&lt;k)))
...

Код модуля ядра:
...
int fi;
fi = calc_freq(n,m,k);
...

Разработчик может не знать о том, что данный макрос разворачивается в операцию с плавающей точкой, которая не допустима в модулях ядра.</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется первоначально обработать исходный код модуля системой компиляции gcc с ключом -msoft-float</ВЕРИФИКАЦИЯ>
<ВЕРТИП>--</ВЕРТИП>
<ПРИМЕЧАНИЯ>проверяется с помощью gcc
We should recommend user to check his gcc command line keys too.</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Правильное использование механизма блокировки преемптивности уровня ядра</Имя>
<ID>0021</ID>
<НАЗНАЧЕНИЕ>Позволяет избежать возможных конфликтов при осуществлении повторного входа в процедуру обратного вызова, предоставляемую драйвером. Использования макросов разделения данных между различными CPU (DEFINE_PER_CPU(), get_cpu_var() и т.д.) недостаточно, так как  механизм преемптивности уровня ядра систем версии 2.6.x допускает условия для создания гонок кода уровня ядра на одном CPU (процедура уровня ядра может быть вытеснена аналогичной в большинстве случаев).
Если повторный вход в процедуру может привести к неверной работе драйвера, то требуется использовать специализированный механизм блокировки вытеснения: preempt_enable()/preempt_disable()/preempt_enable_no_resched()

ВАЖНО: Везде, где это возможно, требуется использовать механизм вытеснения, так как это положительно сказывается на среднем времени реакции системы (например, на внешние прерывания). Поэтому использование блоков кода preempt_disable()/preempt_enable() возможно только в особо критических участках кода (можно провести аналогию с использованием cli()/sti() для блокировки маскируемых прерываний в ядрах 2.4.x).</НАЗНАЧЕНИЕ>
<ТИП>WARNING2</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
...
preempt_disable();
//код, защищенный от ситуации гонок
preempt_enable_no_resched();
//код, не защищенный от ситуации гонок
...
schedule(); //передача управления планировщику
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется осуществлять проверку:
а) Обязательный вызов preempt_enable() после функции preempt_disable() (аналогично случаю использования spin_lock())
б) Если объем кода между вызовами механизма блокировки вытеснения велик (TODO: требуется установить границу) - выдавать предупреждение о том, что разбиение кода на небольшие сегменты, требующие блокировки, положительно скажется на производительности.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ/?</ВЕРТИП>
<ПРИМЕЧАНИЯ>preempt_enable/preempt disable аналогично spinlock
как измерять объем вычислений?

strikov: Imho, we can control only real great deal of code (e.g. more than 10-15 lines). Control of some loops etc it's not important, i think...
But..can Blast make some loops unrolling?</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:АРХИТЕКТУРА
ОСОБЕННОСТИ:UMA/NUMA/COMA</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование нового механизма ожидания, пришедшего на смену специализированных методов sleep_on()/wake_up()</Имя>
<ID>0022</ID>
<НАЗНАЧЕНИЕ>Работа функций sleep_on()/wake_up() не является безопасной в контексте современных SMP/NUMA систем и механизма вытеснения кода ядра, поэтому ожидается их полное исключение из кода ядра (которое по ряду причин не произошло в эксп. версии 2.5.x).
Поэтому, в целях будущей переносимости необходимо использовать новый механизм реализации очередей ожидания:
а) Новая очередь ожидания создается макросом DECLARE_WAIT_QUEUE_HEAD(имя)
б) Создание нового объекта очереди несущего task_struct текущего процесса создается макросом DECLARE_WAITQUEUE(имя, current)
в.1) Добавление объекта в очередь add_wait_queue(&amp;queue, &amp;wait)
в.2) Расширенная группа постановки в очередь ожидания (включает в себя установку состояния STATE_INTERRUPTIBLE/STATE_UNINTERRUPTIBLE с помощью prepare_to_wait())</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>Использование общего подхода:

DECLARE_WAIT_QUEUE_HEAD(queue);
DECLARE_WAITQUEUE(wait, current);
    for (;;) {
        add_wait_queue(&amp;queue, &amp;wait);
        set_current_state(TASK_INTERRUPTIBLE);
	if (condition)
	    break;
        schedule();
	remove_wait_queue(&amp;queue, &amp;wait);
	if (signal_pending(current))
	    return -ERESTARTSYS;
    }
    set_current_state(TASK_RUNNING);

Использование расширенного подхода (макрос prepare_to_wait()):
    DECLARE_WAIT_QUEUE_HEAD(queue);
    DEFINE_WAIT(wait);

    while (! condition) {
        prepare_to_wait(&amp;queue, &amp;wait, TASK_INTERRUPTIBLE);
	if (! condition)
	    schedule();
        finish_wait(&amp;queue, &amp;wait)
    }</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Поиск в коде модуля вызовов функций sleep_on() и выдача предупреждения о том, что данная функция постановки в очередь ожидания является устаревшей и требует замены (возможно предоставление исходного кода примера, т.к. он практически полностью описывает возможную реализацию блока-замены)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_RECOMMENDATION item="y"
line0="{*ID*}"
line1="&lt;table border=&quot;1&quot;&gt;"
line2="&lt;tr&gt;&lt;td&gt;"
line3="&lt;b&gt;&lt;font color=&quot;green&quot;&gt;{*ТИП*}&lt;/font&gt;&lt;/b&gt;"
line4="&lt;/td&gt;&lt;/tr&gt;"
line5="&lt;tr&gt;&lt;td&gt;"
line6="&lt;b&gt;{*ID*}: {*Имя*}&lt;/b&gt;"
line7="&lt;/td&gt;&lt;/tr&gt;"
line8="&lt;tr&gt;&lt;td&gt;"
line9="&lt;b&gt;НАЗНАЧЕНИЕ:&lt;/b&gt;"
line10="{*НАЗНАЧЕНИЕ*}"
line11="&lt;/td&gt;&lt;/tr&gt;"
line12="&lt;tr&gt;&lt;td&gt;"
line13="&lt;b&gt;ПРИМЕР:&lt;/b&gt;"
line14="{*ПРИМЕР*}"
line15="&lt;/td&gt;&lt;/tr&gt;"
line16="&lt;tr&gt;&lt;td&gt;"
line17="&lt;b&gt;ВЕРИФИКАЦИЯ&lt;/b&gt;"
line18="{*ВЕРИФИКАЦИЯ*}"
line19="&lt;/td&gt;&lt;/tr&gt;"
line20="&lt;tr&gt;&lt;td&gt;"
line21="&lt;b&gt;ТИП ВЕРИФИКАЦИИ&lt;/b&gt;"
line22="{*ВЕРТИП*}"
line23="&lt;/td&gt;&lt;/tr&gt;"
line24="&lt;tr&gt;&lt;td&gt;"
line25="&lt;b&gt;ПРИМЕЧАНИЯ&lt;/b&gt;"
line26="{*ПРИМЕЧАНИЯ*}"
line27="&lt;/td&gt;&lt;/tr&gt;"
line28="&lt;tr&gt;&lt;td&gt;"
line29="&lt;b&gt;ХАРАКТЕРИСТИКА&lt;/b&gt;"
line30="{*ХАРАКТЕРИСТИКА*}"
line31="&lt;/td&gt;&lt;/tr&gt;"
line32="&lt;/table&gt;"
generic="ПРАВИЛО"
icon="check_2">
<Имя type="Text" ref="y">Использование упрощенного механизма постановки в очередь ожидания (wait_event())</Имя>
<ID type="Text" prefix="ID ">0023</ID>
<НАЗНАЧЕНИЕ type="Text">Упростить понимание кода и разработку драйвера путем использование пред-реализованных блоков кода постановки в очередь ожидания:
wait_event(queue,event), где event - boolean условие, истинное значение которого будет служить сигналом для возможного перехода задач очереди queue в активное состояние (TASK_RUNNABLE)</НАЗНАЧЕНИЕ>
<ТИП type="Combination" format="RECOMMENDATION" html="y">RECOMMENDATION</ТИП>
<ПРИМЕР type="Text">/arch/sh/drivers/dma/dma-api.c:

if (channel-&gt;flags &amp; DMA_TEI_CAPABLE) {
    wait_event(channel-&gt;wait_queue,          (info-&gt;ops-&gt;get_residue(channel) == 0));
return;
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ type="Text">При использовании функций add_wait_queue()/prepare_to_wait() требуется выводить рекомендацию о необходимости рассмотрения варианта использования функций семейства wait_event()</ВЕРИФИКАЦИЯ>
<ВЕРТИП type="Text">РС</ВЕРТИП>
<ПРИМЕЧАНИЯ type="Text"></ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ type="Text"></СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА type="Text">ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Упрощенный способ использования ожидающих очередей с одним ожидающим и одним инициатором</Имя>
<ID>0024</ID>
<НАЗНАЧЕНИЕ>Упростить понимание кода и процесс реализации ожидающих очередей (надо отметить, что данных упрощенный механизм нашел свое широкое применение в исходном коде ядра, поэтому его можно использовать в драйверах, для которых важна максимальная гибкость и портируемость).</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>Вместо объемного кода помещения задачи в очередь ожидания возможно использование объекта completion следующим образом:

СУБЬЕКТ УПРАВЛЕНИЯ:
DECLARE_COMPLETION(имя);
...
//ожидание некоторого события
wait_for_completion(struct completion*);

ОБЪЕКТ КОНТРОЛЯ ЗА ОЖИДАНИЕМ:
...
//разрешение субъекту продолжить выполнение
complete(struct completion*);</ПРИМЕР>
<ВЕРИФИКАЦИЯ>При обнаружение кода, включенного в правила ID 0022,0023 выдавать предупреждение, о возможности упрощенного использование очередей ожидания.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Необходимость задания имени объекта типа kobject перед его регистрацией в файловой системе sysfs</Имя>
<ID>0028</ID>
<НАЗНАЧЕНИЕ>Предотвратить возможные ошибки или неверное толкование значения указателя имени объекта.
Для задания имени объекта используется функция kobject_set_name(...), прямое использование указателя имени char* k_name недопустимо.</НАЗНАЧЕНИЕ>
<ТИП>ERROR3</ТИП>
<ПРИМЕР>struct kobject mykobj;
kobject_init(&amp;mykobj);
//Обязательное присвоение имени объекту для правильного отображения на sysfs
kobject_set_name(&amp;mykobj,&quot;NAME&quot;);
kobject_add(&amp;mykobj);</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется проверять, задано ли имя объекта к которому применяется метод kobject_add() с использованием функции kobject_set_name(...). Обычно в едином блоке находятся вызовы как функции инициализации счетчика ссылок (kobject_init()) так и установка имени объекта и его отображение на sysfs.

ДОПОЛНИТЕЛЬНО:
Требуется запретить обращение к указателю на имя объекта char* k_name. Его модификация должна проводиться исключительно специализированным методом kobject_set_name(...)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ/РС</ВЕРТИП>
<ПРИМЕЧАНИЯ>1. ДВ
kobject_add не может быть вызван до того как вызвана функция kobject_set_name
2. РС
отлавливать указатель k_name

Примеры системных драйверов для верификации:
$KERNEL_SOURCE/drivers/md/md.c
$KERNEL_SOURCE/drivers/block/elevator.c
$KERNEL_SOURCE/drivers/block/ll_rw_blk.c
$KERNEL_SOURCE/drivers/net/iseries_veth.c
$KERNEL_SOURCE/drivers</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_REJECTED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:SYSFS</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Необходимость возврата всех выделенных в пуле coherent-memory единиц памяти перед его освобождением</Имя>
<ID>0029</ID>
<НАЗНАЧЕНИЕ>Предупредить возможные ошибки в работе драйвера, связанные с освобождением еще используемого региона памяти с помощью функций dma_pool_destroy(struct dma_pool* pool) и pci_pool_destroy(struct pci_pool* pool). К неосвобожденной памяти относятся участки памяти, выделенные с помощью функций dma_pool_alloc() или pci_pool_alloc(), но еще не освобожденные с помощью dma_pool_free() или pci_pool_free().</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>int some_kernel_ehci_module_func(/*non-important data type*/ ehci)
{
	struct ehci_qtd  *qtd;
	dma_addr_t  dma;

	ehci-&gt;qtd_pool = pci_pool_create (&quot;ehci_qtd&quot;, ehci-&gt;hcd.pdev,
			sizeof (struct ehci_qtd),
			32 /* byte alignment  */,
			4096 /* can't cross 4K */,
			flags);
	if (!ehci-&gt;qtd_pool)
	{
		//Some error handling!
	}

	//Some non-important code stuff

	qtd = pci_pool_alloc (ehci-&gt;qtd_pool, flags, &amp;dma);
	//Simple trying to alloc some memory portion from our pci-pool

	if (qtd != 0) {
		memset (qtd, 0, sizeof *qtd);
		qtd-&gt;qtd_dma = dma;                //Working with allocated structure data
		qtd-&gt;hw_next = EHCI_LIST_END;	   //With another one...
		qtd-&gt;hw_alt_next = EHCI_LIST_END;
		INIT_LIST_HEAD (&amp;qtd-&gt;qtd_list);
	}

	//Here, we need to free our allocated memory portion, because pci-pool need to be destroyed

	pci_pool_free (ehci-&gt;qtd_pool, qtd, qtd-&gt;qtd_dma);

	//Now, if all is OK, we can destroy our pci-pool

	if (ehci-&gt;qtd_pool)
	pci_pool_destroy (ehci-&gt;qtd_pool);
	ehci-&gt;qtd_pool = 0;
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется отслеживать все вызовы функций выделения ячеек памяти из coherent-memory pool и требовать (уровень ERROR) их освобождения перед уничтожением самого pool'а.
Методы pci_pool_free(...)/dma_pool_free(...) принимают в качестве одного из параметров адрес, возвращаемый функциями выделения ячейки, поэтому целесообразно проводить верификацию по имени идентификатора указателя.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Примеры системных драйверов для верификации:
$KERNEL_SOURCE/drivers/block/DAC960.c
$KERNEL_SOURCE/drivers/ieee1394/ohci1394.c
$KERNEL_SOURCE/drivers/infiniband/hw/mthca/mthca_av.c
$KERNEL_SOURCE/drivers/usb/gadget/net2280.c

На примере DAC390.c Blast не завершился за 33 минуты.</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_PREPARED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:POOL's/SLAB/SLUB/...
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Необходимость осуществления синхронизации (разделения) доступа к ячейки памяти при работе в режиме DMA</Имя>
<ID>0030</ID>
<НАЗНАЧЕНИЕ>Исключить попытку одновременного доступа к ячейке памяти со стороны устройства и CPU. Результатом такой ошибочной операции может быть искажение реальных передаваемых данных, что приведет к проблемам функционирования драйвера.
Для обеспечения требуемого разделения доступа к выделенному буферу в памяти применяются системные функции pci_dma_sync_single_for_device(...) и pci_dma_sync_single_for_cpu();
pci_dma_sync_single_for_device(...) - применяется для временной блокировки процесса, до момента завершения передачи/чтения со стороны устройства
pci_dma_sync_single_for_cpu(...) - применяется для передачи контроля за выделенным блоком памяти устройству (т.е. оно становится способным к чтению/записи данных, используя DMA)

ИСКЛЮЧЕНИЕ: если работа в DMA режиме представляет из себя исключительно единственную операцию (например обращение к данным, которые были записаны устройством), то возможно использование последовательно функций pci_map_single()/pci_unmap_single() с последующим обращением к буферу (в уже неактивном режиме транзакций), что позволяет НЕ использовать методы синхронизации.</НАЗНАЧЕНИЕ>
<ТИП>ERROR2</ТИП>
<ПРИМЕР>/*From official Linux Kernel Manual*/

	my_card_setup_receive_buffer(struct my_card *cp, char *buffer, int len)
	{
		dma_addr_t mapping;

		mapping = pci_map_single(cp-&gt;pdev, buffer, len, PCI_DMA_FROMDEVICE);

		cp-&gt;rx_buf = buffer;
		cp-&gt;rx_len = len;
		cp-&gt;rx_dma = mapping;

		give_rx_buf_to_card(cp);
	}

	...

	my_card_interrupt_handler(int irq, void *devid, struct pt_regs *regs)
	{
		struct my_card *cp = devid;

		...
		if (read_card_status(cp) == RX_BUF_TRANSFERRED) {
			struct my_card_header *hp;

			/* Examine the header to see if we wish
			 * to accept the data.  But synchronize
			 * the DMA transfer with the CPU first
			 * so that we see updated contents.
			 */
			pci_dma_sync_single_for_cpu(cp-&gt;pdev, cp-&gt;rx_dma,
						    cp-&gt;rx_len,
						    PCI_DMA_FROMDEVICE);

			/* Now it is safe to examine the buffer. */
			hp = (struct my_card_header *) cp-&gt;rx_buf;
			if (header_is_ok(hp)) {
				pci_unmap_single(cp-&gt;pdev, cp-&gt;rx_dma, cp-&gt;rx_len,
						 PCI_DMA_FROMDEVICE);
				pass_to_upper_layers(cp-&gt;rx_buf);
				make_and_setup_new_rx_buf(cp);
			} else {
				/* Just sync the buffer and give it back
				 * to the card.
				 */
				pci_dma_sync_single_for_device(cp-&gt;pdev,
							       cp-&gt;rx_dma,
							       cp-&gt;rx_len,
							       PCI_DMA_FROMDEVICE);
				give_rx_buf_to_card(cp);
			}
		}
	}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Если осуществляется доступ к данным shared-буфера или модификация его содержимого ВНУТРИ цикла pci_map_single()/pci_unmap_single(), то требуется выдавать сообщение о необходимости использования методик синхронизации, описанных выше.
В случае обнаружения выполнения операций над содержимым буфера ЗА ПРЕДЕЛАМИ цикла - выдачу сообщения не производить (см. графу &quot;Исключение&quot;)

ВАЖНО: ТРЕБУЕТСЯ РАСШИРИТЬ ПРАВИЛО НА АНАЛОГИЧНЫЙ НАБОР ФУНКЦИЙ СЕРИИ pci_map_sg()/pci_unmap_sg()/pci_sync_sg_for_cpu()/pci_sync_sg_for_device(). ОТЛИЧИЙ В ОПИСАНИИ ПРАВИЛА НЕТ, ТРЕБУЕТСЯ ИЗМЕНИТЬ ТОЛЬКО СИМВОЛЬНЫЕ ИДЕНТИФИКАТОРЫ ФУНКЦИЙ</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Проверка на использование зарезервированных major-версий при регистрации символьного устройства</Имя>
<ID>0031</ID>
<НАЗНАЧЕНИЕ>Обеспечение проверки передаваемого в функцию регистрации блочного устройства major-значения на факт его соответствия major-версиям стандартных реальных или виртуальных устройств.
Использование зарезервированных major-значений может приводить как к невозможности использования драйвера (если не предусмотрено динамическое переопределение), так и к неоптимальному поведению механизма определения, реализуемого программистом (так как ветка алгоритма, в которой проводится регистрация устройства с зарезервированным значением major-версии, становится неактивной из-за перманентного возврата кода ошибки функцией регистрации)

Major-версии, закрепленные за стандартными устройствами в конкретной версии ядра приведены в системной документации:
$KERNEL_SOURCE_CODE/Documentation/devices.txt</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
...
/*Данный код не предусматривает динамического выделения major-версии, поэтому если в качестве комбинации MAJOR/MINOR выбрать зарезервированную, то работа драйвера будет невозможна по алгоритмическим соображениям*/

/*Пример недопустимой комбинации:
MAJOR=3 MINOR=0-255 - reserved for pseudo-tty*/

dev_t device = MKDEV(MAJOR,MINOR);
if(register_chrdev_region(device,COUNT,&quot;My Device&quot;) &lt; 0)
error_handler();
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется проводить динамически разбор файла Documentation/devices.txt (с другой стороны, список зарезервинновых major-версий является довольно стабильным, в следствии чего возможно ручное внесение данных в анализатор).
В дальнейшем, необходима проверка параметра передаваемого функциям register_chrdev()/register_chrdev_region() на факт совпадения с зарезервированным значением.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Повторная попытка занятия семафора находящегося в режиме MUTEX</Имя>
<ID>0032</ID>
<НАЗНАЧЕНИЕ>Объект типа MUTEX предоставляет исключительно единичный доступ на выполнение ограниченного участка выполняемого кода. В следствие этого повторная попытка осуществить занятие данного MUTEX'а неизбежно приведет к deadlock - ситуации.
Ядро предоставляет единый интерфейс для работы как с полными семафорами (предоставляющими доступ как единичным экземплярам запрашивающего объекта, так и множественным), так и с ограниченными семафорами (мьютексами).
Единственным отличием в использовании является специализированная методика инициализации:
* в случае полных семафоров: sema_init(struct semaphore*, int start_val);
* в случае мьютексов - init_MUTEX(struct semaphore*));
Также широко распространен метод декларирования мьютексов с помощью специализированных макросов:

DECLARE_MUTEX(name) и DECLARE_MUTEX_LOCKED(name).

Из вышеописанного следует, что требуется осуществлять реагирование на объекты, созданные следующими возможными способами:
* init_MUTEX(struct semaphore*)
* DECLARE_MUTEX(name)
* DECLARE_MUTEX_LOCKED(name)
* sema_init(struct semaphore*, 1 /*т.к. семафор, фактически, реализует функционал мьютекса, так как допускает исключительно один объект*/)


Занятие, как семафора, так и мьютекса, осуществляется следующим способом:
* void down(struct semaphore*)


ПРИМЕЧАНИЕ: Использование функций down_trylock(strcut semaphore*) и down_interruptible(struct semaphore*) не подпадает под данное правило, так как возможно повторное занятие семаформа, если первая попытка оказалась неудачной (при возврате !=0 значения)</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
...
struct semaphore sem;
init_MUTEX(&amp;sem);
...
down(&amp;sem);
//некоторый код, который не осуществляет вызов up(&amp;sem);
down(&amp;sem);
...
}
drivers/hwmon/amc6821.c - double mutex unlock bug:
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6-stable.git;a=commitdiff;h=316e2664dcc82e9c5f73360a4fb8f9279a8152ed

drivers/media/video/ov511.c - mutex_unlock:
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.32.y.git;a=commitdiff;h=6e2aa7de04f48bd39955fe0939dc2e02b8941839</ПРИМЕР>
<ВЕРИФИКАЦИЯ>1)Требуется выявить объекты-семафоры, инициализированные одним из способов, перечисленных в графе &quot;НАЗНАЧЕНИЕ&quot;
2)Осуществить контроль за вызовами функций занятия мьютекса-семафора (down(struct semaphore*)) для конкретных выявленных объектов.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Требование осуществления контроля за возвращаемым значением функций занятия семафора</Имя>
<ID>0033</ID>
<НАЗНАЧЕНИЕ>Необходимо требовать от разработчика проверки возвращаемого значения функциями:
* int down_interruptible(struct semaphore*);
* int down_trylock(struct semaphore*)

Принцип функционирования и контроля следующий: если занятие семаформа (как при прерывании выполнения в случае down_interruptible(...), так и при занятости семафора в случае down_trylock(...)) невозможно, возвращаемое значение отлично от нуля (!=0).

Равенство нулю возвращаемого значения следует контролировать, так как лишь при таком возврате код может обращаться к защищенным семафором объектам.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>ssize_t some_driver_callback_write_func(struct file*, const char __user *, size_t, loff_t *)
{
...
if(down_interruptible(&amp;sem))
       return -ERESTARTSYS; //при возврате данного кода система осуществит повторных вход в данную
процедуру
//Гарантированно защищенный код
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Необходимо обеспечить проверку обязательного анализа возвращаемого значения функциями:
* int down_interruptible(struct semaphore*);
* int down_trylock(struct semaphore*)

Осуществлять анализ аргумента функций не требуется, так как контролируется исключительно факт проверки возвращаемого значения.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование наиболее оптимальной схемы ожидания внешнего события с использованием completion-механизма</Имя>
<ID>0034</ID>
<НАЗНАЧЕНИЕ>Для реализации механизма ожидания внешнего события часто применяется следующая программная конструкция:
struct semaphore sem;
/* инициализация мьютекса в 0 состоянии */
init_MUTEX_LOCKED(&amp;sem);
...
/* Функция осуществляющая генерацию внешнего объекта (например, потока), который управляет ожидаемым событием */

ExternalFuncCaller();

/* Обеспечим ожидание генерации события (up(&amp;sem)) со стороны внешнего объекта */

down(&amp;sem);

Недостаток такого кода заключается в том, что механизм функционирования семафоров изначально ориентирован на максимальную производительность в случае частого нахождения объекта семафора в открытом состоянии (т.е. при отсутствии блокировки выполнения) в связи с тем, что в реальных ситуациях потенциальные ситуации взаимоблокировок довольно редки.
В данном же примере семафор ВСЕГДА будет находиться в закрытом состоянии в момент обращения и, следовательно, код будет неоптимальным.

Специально для такого рода операций предусмотрен механизм completion, который представляет собой мьютекс, оптимально осуществляющий функции ожидания.

Создание completion-объекта возможно рядом способов:
* макросом DECLARE_COMPLETION(name)
* с помощью раздельной инициализации
   struct completion comp;
   init_completion(&amp;comp);

Ожидание события осуществляется функцией wait_for_completion(struct completion*)

Внешний объект генерирует событие с помощью функций:
* void complete(struct completion*)
* void complete_all(struct completetion*)

ПОЯСНЕНИЕ: Отличие двух функций генерации события заключается в том, что вызов complete_all(...) осуществляет запуск ВСЕХ задач, находящих в очереди ожидания wait_queue, а не единственной.</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
DECLARE_COMPLETION(compl);
...
ExternalThreadSmartInitializer(&amp;compl);
wait_for_completion(&amp;compl);
}

int external_kernel_level_thread(struct completion* compl)
{
...
/* Код, завершения выполнения которого требуется ожидать */

/* генерация события для ожидающего потока  */
complete(compl);
}
{</ПРИМЕР>
<ВЕРИФИКАЦИЯ>На мой взгляд возможны два пути верификации:

Реагировать на наличие вызовов:
   init_MUTEX_LOCKED(...) //прямое создание мьютекса
   sema_init(...,0) //создание блокированного семафора
Так как ЧАЩЕ ВСЕГО данный подход к инициализации применяется исключительно в completion-заменимых ситуациях. На данном этапе можно выдавать предупреждение о неоптимальном использовании.

Второй вариант является расширенным, кроме описанных методов пункта 1, следует проверять наличие явного вызова одного из down-методов семафоров (down(...),down_trylock(...),down_interruptible(...)) после инициализации семафора (т.е. отсутствие явных вызовов up-конструкций).

ПРИМЕЧАНИЕ: Ошибочного обнаружения up(...) вызова внешней процедуры (поцедуры создаваемого потока, например) произойти не может, тк процедура является callback и ее ЯВНОГО вызова не происходит.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Использование устаревшего механизма реализации блокировок типа &quot;критическая секция&quot;</Имя>
<ID>0035</ID>
<НАЗНАЧЕНИЕ>Рекомендовать разработчикам избегать ранее распространенного метода блокировки, реализуемого специализированным циклом ожидания.
Данный метод не исключает ждущий процесс из очередей выполнения процессора (runqueue) и, следовательно, впустую тратит системные ресурсы, связанные с лишним переключением задач на выполнение и на отработку цикла.

Вместо данной операции следует использовать методы, использующие современные механизмы очередей ожидания.
К таким механизмам относятся:
* семаформы
* мьютексы
* completion's</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
...
/* TSL механизм является атомарным, поэтому может быть использован как реализация spin-блокировки */
while(test_and_set_bit(nr, addr) != 0)
       wait_some_time();

/* Защищенный от множественного входа код */

/* Освобождение механизма блокировки */
if(test_and_clear(nr, addr) == 0)
         something_went_wrong();
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>В большинстве случаем реализацию spin-блокировки данным методом осуществляют именно в такой семантике:
while(test_and_set_bit(...) != 0) {}

В связи с этим я считаю, что возможна простая regexp проверка на соответствие данному шаблону.

ПРИМЕЧАНИЕ: Требуется определить, достаточно ли regexp проверки для выявления всех случаев применения данного подхода</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование архитектурно-унифицированного механизма определения &quot;порядка&quot; объема выделяемой страничной памяти</Имя>
<ID>0036</ID>
<НАЗНАЧЕНИЕ>Распространенной ошибкой при выделении памяти с использованием механизма get_free_pages(..., order) является неявное использование значения размера страницы равного 4Кб (свойственного x86 архитектуре с PSE=0).
Т.е. если необходимо осуществить выделение 16Кб страничной памяти, значение &quot;порядка&quot; order принимается равным 2 (4^2=16).
Данная ошибка является труднообнаруживаемой на x86 архитектуре, так как операционные системы не используют PSE (4Мб страницы), но приводит к неверному функционированию драйвера при использовании на иной архитектуре.

Интерфейс ядра предоставляет удобный механизм получения значения &quot;порядка&quot; на призвольной архитектуре.
Данный интерфейс представлен функцией-макросом get_order(size), который использует значение размера страницы на текущей архитектуре PAGE_SIZE.</НАЗНАЧЕНИЕ>
<ТИП>ERROR3</ТИП>
<ПРИМЕР>#include &lt;asm/page.h&gt;

int some_kernel_module_func()
{
...
/* получение значение порядка перекрывающее наши требования по объему выделяемой памяти */
int order = get_order(16 * 1024);

/* осуществляем выделение требуемого объема памяти */
buf = get_free_pages(GFP_KERNEL,order);

}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется &quot;отследить&quot; происхождение величины, переданной функции get_free_pages в качестве второго параметра (order).
Это значение должно быть прямо или косвенно получено вызовом метода get_order(size).

ПРИМЕЧАНИЕ: Требуется рассмотреть вариант получения размера &quot;порядка&quot; вручную с использованием define-значения PAGE_SIZE. С одной стороны, такой подход довольно редко, но, с другой, не является ошибочным, т.к. использует стабильные системные средства.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ
ОСОБЕННОСТИ:ОТЛИЧНЫЕ ОТ x86 АРХИТЕКТУРЫ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Введение рекомендуемой задержки при использовании механизма определения номера линии прерывания, используемого устройством</Имя>
<ID>0037</ID>
<НАЗНАЧЕНИЕ>Обеспечить оптимальную работу механизма (предоставляемого ядром) определения линии прерывания, занимаемой управляемым устройством.
Шины PC-совместимых машин обладают особенностью, которая затрудняет идентификацию линии прерывания: номер линии зависит от физического расположения платы расширения (например, от номера занимаемого слота).

Специализированный механизм, представленный функциями probe_irq_on()/probe_irq_off(...), функционирует следующим образом:

1) С помощью функции probe_irq_on() осуществляется  активация всех незанятых (в качестве обработчика устанавливается значение NULL) прерываний с дальнейшим сохранением их списка в возвращаемой битовой карте

2) Драйвер сообщает устройству (используя порты ввода-вывода) о необходимости воспроизвести активацию линии прерывания.

3) ТРЕБУЕМАЯ ЗАДЕРЖКА, связанная с необходимостью ожидания реакции устройства на запрос через порты ввода-вывода

3.1) При обнаружении активации линии прерывания, обработчик который равен NULL; производится ее дизактивация на уровне ОС

4) Использование механизма probe_irq_off(...) позволяет сравнить ранее полученный список активированных прерываний и системный список, в котором одно из прерываний будет дизактивировано (см. пункт 3.1)

5) Делается вывод о том, что дизактивированное прерывание используется управляемым устройством.

Если не предусмотреть задержку (п.3), то велика вероятность что потребуется дополнительная/ые итерация/ии цикла (который обычно используется при таком подходе к определению линии прерывания), т.к. устройство не успеет отреагировать на запрос прерывания или контроллер прерывания не сможет подать информацию на вход процессора вовремя.

Реализовать задержку удобнее всего можно с использованием функции udelay(delay)</НАЗНАЧЕНИЕ>
<ПРИМЕР>int count = 0;
do {
     unsigned long mask;
     mask = probe_irq_on( );
     outb_p(0x10,short_base+2); /* запрос на прерывание к устройству */
     outb_p(0x00,short_base);
     outb_p(0xFF,short_base);
     outb_p(0x00,short_base+2);
     udelay(5);
     short_irq = probe_irq_off(mask);
     if (short_irq = = 0) {
         printk(KERN_INFO &quot;short: no irq reported by probe\n&quot;);
         short_irq = -1;
     }
} while (short_irq &lt; 0 &amp;&amp; count++ &lt; 5);
                     if (short_irq &lt; 0)
                          printk(&quot;short: probe failed %i times, giving up\n&quot;, count);
/* линия прерывания, используемая управляемым устройством, обнаружена  */</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Необходимо осуществлять  проверку наличия процедуры задержки между вызовами probe_irq_on()/probe_irq_off(...). Возможны два пути:
1) Требовать обязательного вызова именно udelay(...), как наиболее общего и часто используемого метода
2) Осуществлять интеллектуальную проверку на наличие ожидающей процедуры (это может быть, например, помещение в очередь ожидания и передача управления планировщику)

В пользу первого варианта говорит то, что использование расширенных методов ожидания практически не используется в данном контексте.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВРЕМЕНЕМ ЗАДЕРЖКИ
КАТЕГОРИЯ:I/O</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование барьера памяти при работе с I/O регистрами</Имя>
<ID>0038</ID>
<НАЗНАЧЕНИЕ>Предотвратить возможность нарушения работы алгоритма управления удаленым устройством (использующим одну из шин рабочей станции), связанную как с различными оптимизационными воздействиями со стороны компилятора с одной стороны, так и с возможными перестановками выполняемых инструкций в исполняемом конвейере CPU.
В отличии от доступа к оперативной памяти машины (который не имеет стороннего действия, т.е. side-effect'a), обращение к регистрам управления внешнего устройства такой эффект имеет, потому как определяет способ функционирования устройства.

Барьеры памяти - специальные функциональные единицы (макросы) ядра, которые осуществляют контроль за РЕАЛЬНОЙ последовательностью выполнения операций к I/O регистрам/портам:

void wmb() /* завершение всех операций записи в I/O порты */
void rmb() /* завершение всех операций чтения из I/O портов */
void mb() /* завершение всех операций чтения/записи I/O портов */
void read_barrier_depends() /* ослабленная версия, ожидающая завершения доступа только к определенным портам/регистрам */

С помощью данных макросов возможно осуществление контроля за последовательностью запросов в необходимых случаях работы с устройством.

Однако, следует помнить, что использование данных макросов блокирует работает различные системы оптимизации (как уровня компиляции, так и уровня выполнения) и в целом замедляет работу драйвера.</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{

writel(dev-&gt;registers.addr, io_destination_address);
writel(dev-&gt;registers.size, io_size);
writel(dev-&gt;registers.operation, DEV_READ);
wmb(); /* требование завершения передачи всех операций записи в регистры управления, перед финальной операцией */
writel(dev-&gt;registers.control, DEV_GO);

}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется выдавать предупреждение о возможной некорректной работе устройства в случае последовательного частого доступа к управляющим регистрам, в отсутствии макросов &quot;барьеров памяти&quot;.</ВЕРИФИКАЦИЯ>
<ПРИМЕЧАНИЯ>ПРИМЕЧАНИЕ: Следует определить количественную границу последовательных обращений к I/O регистрам.

ПРИМЕЧАНИЕ: Правило не представлено как ERROR по причине того, что в некоторых случаях, когда представленный метод используется неверным образом, возможно снижение общей производительности системы.</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование spin lock</Имя>
<ID>0039</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.25.y.git;a=commit;h=83c7c693ed3e61535ad6a097ad991a88aafc54b8

Запрет проведения повторного освобождения блокировки функцией spin_unlock_irqrestore ()

drivers/char/specialix.c:

@@ 2109

sx_out(bp, CD186x_CAR, port_No(port));
/* освобождение блокировки */
spin_unlock_irqrestore(&amp;bp-&gt;lock, flags); if (I_IXOFF(tty)) {
   /* при определенных условиях возможен вторичный вызов */
   spin_unlock_irqrestore(&amp;bp-&gt;lock, flags);
   sx_wait_CCR(bp);
   spin_lock_irqsave(&amp;bp-&gt;lock, flags);
   sx_out(bp, CD186x_CCR, CCR_SSCH2);

...</НАЗНАЧЕНИЕ>
<ПРИМЕР>pcspkr.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Нельзя захватывать spin_lock дважды, нельзя освобождать незахваченный spin_lock.
При завершении все spin_lock должны быть освобождены.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Модифицируем &lt;linux/spinlock.h&gt;
#include &lt;env-spinlock.h&gt;
--------------------------------
#include &lt;assert.h&gt;
extern int x;
#define spin_lock_irqsave(lock,flags) {assert((x)==0); (x)=1; }
#define spin_unlock_irqrestore(lock,flags) {assert((x)==1); (x)=0; }
#define spin_lock_on_exit(lock) {assert((x)==0); }</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_PREPARED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Необходимость атомарного выделения памяти при захвате блокировки</Имя>
<ID>0043</ID>
<НАЗНАЧЕНИЕ>Запрет выполнения блокируемого выделения памяти (отсутствие флага GFP_ATOMIC при осуществлении обращения к функциям аллокации: семейства kmalloc, vmalloc, get_free_pages) при активном удержании блокировки.
Блокируемое выделение памяти характеризуется возможным переключением на другие выполняющиеся процессы если память не может быть выделена в настоящее время системой аллокации (например SLAB).
Результатом данного неверного поведения может стать как общее снижение производительности системы (так как другие системные процессы - в том числе процессы реального времени - использующие заблокированный ресурс, будут также зависимыми от системы выделения памяти, в следствие того, что ресурс будет освобожден только после ее получения), так и выведение ОС из строя на embedded-системах (при отсутствии MMU и страничной системы адресации) из-за неявного deadlock при невозможности выделения памяти.
ПОЯСНЕНИЕ:
При отсутсвии MMU невозможна выгрузка в swap некоторых страничных фреймов для повторного использования памяти. Пусть некоторый ядровой модуль (например драйвер) предварительно захватив блокировку осуществляет блокируемый вызов функции выделения памяти и уходит в состояние ожидания. Вернуться в активное состояние (и освободить
блокировку) он сможет только если какой-то другой ядровой модуль вернет часть своих страниц системе. Embedded системы обычно работают с малым числом ядровых нитей/процессов, причем большинство из них - системные (а не модули/драйверы). Вполне вероятна ситуация когда системный процесс ждет снятия установленной блокировки и физически не сможет осуществить освобождение ряда своих страничных фреймов. Такая ситуации ведет к краху части или всей системы.</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/net/wireless/orinoco/wext.c:
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=5b0691508aa99d309101a49b4b084dc16b3d7019</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Следует выделить ряд функций захвата (и освобождения) блокировок.
На настоящий момент из заголовков ядра можно выделить следующий список:

/* Захват блокировки */
spin_trylock(lock)
read_trylock(lock)
write_trylock(lock))
spin_lock(lock)
spin_lock_nested(lock, subclass)
spin_lock_nested(lock, subclass)
write_lock(lock)
read_lock(lock)
spin_lock_irqsave(lock, flags)
read_lock_irqsave(lock, flags)
write_lock_irqsave(lock, flags)
spin_lock_irqsave_nested(lock, flags, subclass)
spin_lock_irq(lock)
spin_lock_bh(lock)
read_lock_irq(lock)
read_lock_bh(lock)
write_lock_irq(lock)
write_lock_bh(lock)
spin_trylock_irq(lock)
spin_trylock_irqsave(lock, flags)
write_trylock_irqsave(lock, flags)
double_spin_lock(spinlock_t *l1, spinlock_t *l2, bool first) double_spin_unlock(spinlock_t *l1, spinlock_t *l2, bool first)

/* Освобождение блокировки */
spin_unlock(lock)
read_unlock(lock)
write_unlock(lock)
spin_unlock_irq(lock)
read_unlock_irq(lock)
write_unlock_irq(lock)
spin_unlock_irqrestore(lock, flags)
spin_unlock_bh(lock)
read_unlock_irqrestore(lock, flags)
read_unlock_bh(lock)
write_unlock_irqrestore(lock, flags)
write_unlock_bh(lock)
spin_trylock_bh(lock)

Объект блокировки представлен параметром `lock` Необходимо отслеживать занятие и освобождение всех блокировок в программе.
Если в момент обращения к функции блокирующего выделения памяти (отсутствие флага GFP_ATOMIC) существуют блокированные ресурсы, необходимо выдать предупреждение о возможном некорректном поведении (с указанием имени не освобожденного объекта)

ДОПОЛНЕНИЕ:
Возможно, следует рассмотреть возможность выделения только некоторых системных объектов, сохранение занятого состояния которых недопустимо при блокируемом вызове. Иначе мы нарвемся на огромное количество ложных срабатываний (на внутренние lock'и т.д.)

ПОЯСНЕНИЕ:
Потенциально, возможно выделение ряда низкоуровневых функций и введение в модель некоторых дополнительных заголовков ядра, потому как количество контролируемых функций велико и имеет тенденцию к постоянному увеличению.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ФЛАГИ УПРАВЛЕНИЯ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:POOL's/SLAB/SLUB/...
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Запрет блокируемого выделения памяти в функциях обратного вызова (callback)</Имя>
<ID>0044</ID>
<НАЗНАЧЕНИЕ>Большинство callback-функций вызывается core частью ядра ОС в контексте множественного захвата блокировок ресурсов, а также часто в ситуациях, когда нежелательно внесение дополнительного стохастического фактора ожидания (неопределенность следует из механизма отложенного выделения памяти). В следствие этого не следует использовать блокируемое выделение памяти в такого рода частях модулей ядра.</НАЗНАЧЕНИЕ>
<ВЕРИФИКАЦИЯ>Существует два потенциальных варианта верификации:
* прямая верификация
Необходимо выделить все существующие методы регистрации callback-функций (их символические имена) и ассоциировать с каждым `объектом` функции указатель на то, используется ли она в callback контексте. В дальнейшем при анализе кода функции возможна выдача предупреждение об использовании блокируемого выделения памяти в контексте callback-вызова.

* косвенная верификация
Отслеживать сам факт передачи указателя на какую-либо внутреннюю функцию исследуемого модуля в качестве параметра системной функции ОС. В 95% случаев такие вызовы используются для регистрации callback-обработчиков.

ИСКЛЮЧЕНИЕ:
Обратные вызовы драйверов подсистемы USB (usb_probe / usb_disconnect) могут использовать выделение памяти без флага GFP_ATOMIC.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ФЛАГИ УПРАВЛЕНИЯ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:CALLBACK
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:POOL's/SLAB/SLUB/...
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Использование расширенного интерфейса выделения памяти kzalloc() вместо комбинации kmalloc() + memset(,0,sizeof(object))</Имя>
<ID>0045</ID>
<НАЗНАЧЕНИЕ>-----------------------------------------------------------------------------
1.
-----------------------------------------------------------------------------

Функция ядра kzalloc() выполняет выделение требуемого объема памяти (например из внутреннего slab-кэша) с последующим обнулением данной области.
Результат выполнения аналогичен применению комбинации функций kmalloc() (выделение неинициализированной памяти) + memset(,0,) (первичная инициализация памяти нулевыми значениями), однако позволяет избежать как увеличения временных затрат на дополнительный вызов функции (это особенно актуально для x86+ архитектур, в силу ресурсоемкости проведения там данной операции), так и роста объема исходного кода драйвера.
Интерфейс kzalloc() рекомендуется использовать во всех новых драйверах/модулях ядра, а также по возможности переводить на него уже существующие проекты.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

(простой для обнаружения вариант)
drivers/char/ip2/ip2main.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg26711.html

(более сложный для обнаружения вариант с ветвлением)
drivers/char/consolemap.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg26708.html

drivers/pci/hotplug/cpqphp_ctrl.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg24165.html

drivers/usb/misc/ftdi-elan.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg24224.html

-----------------------------------------------------------------------------
2.
-----------------------------------------------------------------------------

drivers/message/fusion/mptctl.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg25048.html

2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=25c16fffa8ed82d3ef31980d76ff95d3c6430f00

Отсутствие необходимости в инициализации нулевыми значениями регионов памяти, выделенных с использованием функции kzalloc

drivers/net/ehea/ehea_main.c:

@@ 2210

cb1 = kzalloc(PAGE_SIZE, GFP_KERNEL);
if (!cb1) {
   ehea_error(&quot;no mem for cb1&quot;);
   goto out;
}

/* нет необходимости в применении дополнительных процедур инициализации */ memset(cb1-&gt;vlan_filter, 0, sizeof(cb1-&gt;vlan_filter));</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.24 -&gt; drivers/char/ip2/ip2main.c
2.6.24 -&gt; drivers/char/consolemap.c
2.6.24 -&gt; drivers/pci/hotplug/cpqphp_ctrl.c
2.6.24 -&gt; drivers/usb/misc/ftdi-elan.c
2.6.24 -&gt; drivers/message/fusion/mptctl.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Необходимо обнаруживать использование следующих конструкций:
pB = kmalloc( sizeof(...), );
/* Код не использующий буфер на который указывает pB и не изменяет сам указатель */
/* !!! Обычно проверка вида: if (pB == 0) { реакция на ошибочное поведение } !!! */
memset( pB, 0, sizeof(...) );

При обнаружении следует рекомендовать использовать конструкцию вида
pB = kzalloc( sizeof(...), ...);</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Сделано для consolemap.c, потребовалось использовать assert в виде макроса вместо функции, так как иначе Blast не обнаруживал новых предикатов.</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>EXAMPLE_DONE</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Предупреждение попыток разыменования NULL-указателей</Имя>
<ID>0046</ID>
<НАЗНАЧЕНИЕ>Одной из наиболее распространенных проблем написания модулей ядра является ошибочное исключение кода проверки полученного из под-функций указателя на равенство нулю перед его дальнейшим разыменованием.
Для успешного выявления такого рода проблем, необходимо осуществить формирование общей концепции &quot;глубины&quot; реализуемой нашим средством модели: либо мы обеспечиваем средство подробной базой возможных возвращаемых значений из интересующей части функций ядра, либо осуществляем анализ кода вызываемой функции во время осуществления статического анализа.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/isdn/capi/kcapi.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg25978.html

drivers/isdn/capi/capidrv.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg25976.html

drivers/net/wireless/libertas/cmd.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg22758.html

ДОПОЛНЕНИЯ ОТ 06.03.2008:

(простой для обнаружения вариант)
drivers/net/pcmcia/nmclan_cs.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg19846.html

(простой для обнаружения вариант)
drivers/net/s2io.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg17216.html

(необычный вариант, так как осуществляется ошибочная проверка на NULL-указатель (выбрана неверная переменная для проверки))
drivers/auxdisplay/cfag12864b.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg20769.html

ДОПОЛНЕНИЯ ОТ 12.03.2008:

drivers/net/ns83820.c:
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg15022.html

drivers/media/video/se401.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg09583.html

ДОПОЛНЕНИЯ ОТ 08.05.2008:
net/ipv4/ip_fragment.c:
http://kerneltrap.org/mailarchive/git-commits-head/2008/3/24/1244904</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.24 -&gt; drivers/isdn/capi/kcapi.c::old_capi_manufacturer()
2.6.24 -&gt; drivers/isdn/capi/capidrv.c::send_message()
2.6.24 -&gt; drivers/net/wireless/libertas/cmd.c

ДОПОЛНЕНИЯ ОТ 06.03.2008:

2.6.23 -&gt; drivers/net/pcmcia/nmclan_cs.c
2.6.23 -&gt; drivers/net/s2io.c
2.6.23 -&gt; drivers/auxdisplay/cfag12864b.c

ДОПОЛНЕНИЯ ОТ 12.03.2008:

2.6.22 -&gt; drivers/net/ns83820.c

2.6.22 -&gt; drivers/media/video/se401.c

ДОПОЛНЕНИЯ ОТ 23.04.2008:

2.6.25 -&gt; drivers/usb/serial/usb-serial.c
2.6.25 -&gt; drivers/media/radio/radio-si470x.c

ДОПОЛНЕНИЯ ОТ 08.05.2008:
2.6.25 -&gt; net/ipv4/ip_fragment.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Необходимо обнаруживать использование следующих конструкций:

ptr = func(...); /* Функция возвращает указатель, который может иметь нулевое значение */
... = *p; /* Подразумевается также неявное разыменование (обращение к полям структуры и т.п.) */

При обнаружении следует рекомендовать использовать конструкцию вида:

ptr = func(...);
if (!ptr)
   { обработка исключительной ситуации  }
... = *p;</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Два подправила:
1. Перед разыменованием возвращенного значения должна быть проверка на NULL
2. Некоторым функциям kernel core API нельзя передавать нулевые указатели

В обоих случая принято решение составить список функций обладающих соответствующими свойствами:
1. Функции, которые могут вернуть нулевой указатель
2. Функции, которым нельзя передавать нулевой указатель в качестве параметра</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ЗНАЧЕНИЕ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
ПЕРЕМЕННЫЕ:ЗНАЧЕНИЕ
КАТЕГОРИЯ:ГЛОБАЛЬНЫЕ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование в качестве индекса элемент массива величины, значение которого потенциально может быть отрицательным</Имя>
<ID>0047</ID>
<НАЗНАЧЕНИЕ>При реализации callback функций драйверов или интерфейсных функций подсистем необходимо контролировать диапазон передаваемых в функцию значений. Использование для индексации массива потенциально отрицательных значений может привести к краху системы. Требуется вводить проверку значения индексирующей переменной.

Данная ситуация также возможна при отсутствии проверки на величину возвращаемого системной функцией значения. Необходимо одним из вышеописанных способов определять возможный интервал возвращаемого значения и осуществлять контроль дальнейшего использования переменной в качестве индекса элемента массива.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/mtd/ubi/kapi.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg24843.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.24 -&gt; drivers/mtd/ubi/kapi.c::ubi_open_volume()</ПРИМЕР>
<ВЕРИФИКАЦИЯ>void func(int num, ...) /* Отсутстие ограничения на диапазон передаваемой величины  */
{
    ... = ubi_devices[ubi_num]; /* Использование данной величины для индексации массива */

    ...
}

Необходимо требовать явно проверки значения переданной величины перед ее использованием в качестве индекса:

void func(int num, ...) /* Отсутстие ограничения на диапазон передаваемой величины  */
{
    if (num &gt;= 0)
    {
    ... = ubi_devices[ubi_num]; /* Использование данной величины для индексации массива */

    ...
}</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ЗНАЧЕНИЕ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
ПЕРЕМЕННЫЕ:ЗНАЧЕНИЕ
КАТЕГОРИЯ:ГЛОБАЛЬНЫЕ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Рекомендуемое объявление всех функций модуля не предназначенных для предоставления специализированного интерфейса взаимодействия внешним объектам как static-функций</Имя>
<ID>0048</ID>
<НАЗНАЧЕНИЕ>При отсутствии у функции явного спецификатора static механизм компиляции/сборки автоматически делает возможным импорт данной функции внешними модулями (т.е. заносит ее в список экспорта объектного .ko компонента).
Данного поведения следует максимально избегать вследствие следующих причин:
* возможное появление ошибок в связи с совпадением имен функций, экспортируемых из различных модулей (причем ситуации можно было избежать так как одна из функций предназначена исключительно для внутреннего использования)
* увеличение размера объектного компонента в связи с дополнительной записью секции экспорта
* возможность связывания и вызова функции, которая изначально предназначалась исключительно для внутреннего использования, внешними модулями (драйверами), что может приводить как к случайному, так и к преднамеренному нанесению вреда системе

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

(простой для обнаружения вариант)
drivers/usb/serial/sierra.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg19805.html

(простой для обнаружения вариант)
drivers/char/hvc_console.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg17453.html

(более сложный вариант с возможными доп. проверками)
drivers/mmc/core/core.c
drivers/mmc/core/sd_ops.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg19632.html

ДОПОЛНЕНИЯ ОТ 12.03.2008:

drivers/video/hecubafb.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg12003.html

drivers/video/display/display-sysfs.c (display_class)
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg11991.html

drivers/isdn/capi/capiutil.c (cdebbuf_alloc)
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg11870.html

drivers/char/hvc_console.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg11671.html

drivers/macintosh/mac_hid.c [POWERPC]
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg12104.html

drivers/misc/thinkpad_acpi (fan_mutex)
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg09818.html

drivers/net/s2io.c (vlan_strip_flag)
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10071.html

drivers/net/qla3xxx.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10069.html

ДОПОЛНЕНИЯ ОТ 08.05.2008:
block/blk-settings.c:
http://kerneltrap.org/mailarchive/git-commits-head/2008/2/19/911094
block/blk-ioc.c:
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg41174.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.23 -&gt; drivers/usb/serial/sierra.c
2.6.23 -&gt; drivers/mmc/core/core.c
2.6.23 -&gt; drivers/mmc/core/sd_ops.c
2.6.23 -&gt; drivers/char/hvc_console.c [POWERPC]

ДОПОЛНЕНИЯ ОТ 12.03.2008:

2.6.22 -&gt; drivers/video/hecubafb.c

2.6.22 -&gt; drivers/video/display/display-sysfs.c (display_class)

2.6.22 -&gt; drivers/isdn/capi/capiutil.c (cdebbuf_alloc)

2.6.22 -&gt; drivers/char/hvc_console.c

2.6.22 -&gt; drivers/macintosh/mac_hid.c [POWERPC]

2.6.22 -&gt; drivers/misc/thinkpad_acpi (fan_mutex)

2.6.22 -&gt; drivers/net/s2io.c (vlan_strip_flag)

2.6.22 -&gt; drivers/net/qla3xxx.c

ДОПОЛНЕНИЯ ОТ 23.04.2008:
2.6.25 -&gt; drivers/atm/idt77252.c
- idt77252_send()
- idt77252_dev_close()
2.6.25 -&gt; drivers/atm/he.c
- read_prom_byte()
2.6.25 -&gt; drivers/watchdog/hpwdt.c
- asminline_call()
2.6.25 -&gt; drivers/fs/ocfs2/dlmglue.c
- ocfs2_process_blocked_lock()
2.6.25 -&gt; drivers/fs/ocfs2/heartbeat.c
- ocfs2_node_map_init()
2.6.25 -&gt; drivers/media/video/em28xx/em28xx-core.c
- em28xx_write_reg_bits()
2.6.25 -&gt; drivers/media/video/em28xx/em28xx-core.c
- em28xx_vdev_init()

ДОПОЛНЕНИЯ ОТ 08.05.2008:
2.6.25 -&gt; block/blk-settings.c
2.6.25 -&gt; block/blk-ioc.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Явные методы обнаружения потенциальных static-функций:
* отсутствие прототипа функции в заголовочных .h файлах, используемых внешними модулями
* отсутствие конструкции вида EXPORT_SYMBOL (symbol_name) в коде модуля ядра или его заголовочного файла
* наличие атрибутов функций инициализации или деактивации (например __init/__exit)

Неявные методы:
* функция используется в callback-контексте
* функция активно (!) используется в коде модуля

drivers/char/vr41xx_giu.c:

static int __devinit giu_probe(struct platform_device *dev)
{
    ...
    retval = register_chrdev(major, &quot;GIU&quot;, &amp;gpio_fops);
    ...
}

static const struct file_operations gpio_fops = {
    .owner        = THIS_MODULE,
    .read        = gpio_read,
    .write        = gpio_write,
    .open        = gpio_open,
    .release    = gpio_release,
};

STATIC ssize_t gpio_read(struct file *file, char __user *buf, size_t len,
                         loff_t *ppos)
{
    ...
}</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>АТРИБУТЫ:ФУНКЦИИ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Удержание spinlock'а допустимо только в ATOMIC-контексте</Имя>
<ID>0049</ID>
<НАЗНАЧЕНИЕ>Удерживающему spin-блокировку процессу запрещается переходить в неактивное (sleep) состояние (например в связи с временным отсутствием требуемого системного ресурса).
Spin-блокировки по своей природе являются активными, т.е. не переводят процесс в состояние сна при невозможности поподания в критическую секцию кода, а выполняют циклические попытки захвата блокировки.
В связи с этим, если процесс, удерживающий такого рода блокировку переходит в режим ожидания (сна), то он обрекает ряд конкурирующих за данный разделяемый ресурс процессов на неоправданную трату большого объема системных ресурсов (т.к. они будут исполнять цилические попытки захвата блокировки на протяжении всего кванта времени).
В ряде случаев такое поведение может привести также к ситуации взаимной блокировки.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/usb/serial/usb-serial.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg19804.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

(множественные вхождения разнообразной сложности)
2.6.23 -&gt; drivers/usb/serial/usb-serial.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Требуется введение нового мета-атрибута функции &quot;возможность перехода в неактивное состояние&quot;, который будет определяться средством статического анализа. Первичный набор функций (25-50 низкоуровневых вызовов), обладающих данным атрибутом, будет генерироваться экспертным методом; все более высокоуровневые функции будут наследовать данный атрибут от своих под-вызовов. Следует также обратить внимание на то, что наличие данного атрибута может также определяться одним или несколькими параметрами определенного вызова (или их сочетанием).

В дальнейшем следует требовать освобождения всех удерживаемых spin-блокировок перед выполнением вызовов, обладающих атрибутом &quot;возможность перехода в неактивное состояние&quot;
Другим возможным решением данной проблемы может являться использование других типов блокировок, например mutex'ов или семафоров, которые переводят процесс в режим ожидания, находясь в захваченном другим объектом состоянии.

!!! Следует также учитывать все НЕЯВНО захваченные spin-блокировки (например, путем вызова какой-либо системной функции), что потребует проводить более глубокий анализ &quot;окружающего&quot; кода модуля ядра

drivers/usb/serial/usb-serial.c:

Код содержит потенциальную ошибку, в связи с тем, что на момент вызова функции kref_get(), которая может перевести процесс в режим ожидания, удерживается спин-блокировка table_lock

struct usb_serial *usb_serial_get_by_index(unsigned index)
 {
        struct usb_serial *serial;

        spin_lock(&amp;table_lock); // захват spin-блокировки

        serial = serial_table[index];

        if (serial)
                kref_get(&amp;serial-&gt;kref); /* функция может переводить процесс в режим ожидания!!! */
        spin_unlock(&amp;table_lock);

        return serial;
 }

Решение проблемы переходом на иной вариант блокироки (мьютексы)

struct usb_serial *usb_serial_get_by_index(unsigned index)
 {
        struct usb_serial *serial;

        mutex_lock(&amp;table_lock);
        serial = serial_table[index];

        if (serial)
                kref_get(&amp;serial-&gt;kref);

        mutex_unlock(&amp;table_lock);
        return serial;
 }</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Повторный захват блокировки (явный или неявный)</Имя>
<ID>0050</ID>
<НАЗНАЧЕНИЕ>В отличии от реализаций в других операционных системах, спин-блокировки в ОС Linux не рекурсивны. Это означает, что если поток пытается захватить блокировку, которую он уже удерживает, то этот поток начнет периодическую проверку, ожидая, пока он сам не освободит блокировку. Это приводит к тупиковым ситуациям (самоблокировкам)
В явном виде данная ситуация почти не встречается, но распространен еще неявный вариант (когда какая либо функция, чаще всего внешняя, осуществляет попытки занять блокировку, которая уже удерживается данным модулем)

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/edac/edac_device.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg18392.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.23 -&gt; drivers/edac/edac_device.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Следует обеспечивать накопление данных об использовании блокировок внутри внешних функций:
* статические данные
  для ряда низкоуровневых функций следует явно перечислить используемые ими блокировки
* динамически генерируемые данные
  требуется проводить анализ исходного кода вызываемых функций с целью постоения списка захватываемых блокировок

В дальнейшем, на момент каждого вызова функции, следует осуществлять проверку, не осуществлен ли захват используемой функцией блокировки. Если это так - необходимо потребовать от разработчика предварительного осовобождения блокировки.

drivers/edac/edac_device.c:

void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
                                        unsigned long value)
{
        mutex_lock(&amp;device_ctls_mutex); /* захват блокировки device_ctls_mutex */

        /* cancel the current workq request */
        edac_device_workq_teardown(edac_dev); /* функция осуществляет захват блокировки device_ctls_mutex */
                          /*                что приводит к самоблокировке             */

        /* restart the workq request, with new delay value */
        edac_device_workq_setup(edac_dev, value);

    ...

}

Решением проблемы является более поздний захват мьютекса (блокировки), уже после вызова функции edac_device_workq_teardown()

void edac_device_reset_delay_period(struct edac_device_ctl_info *edac_dev,
                                        unsigned long value)
 {

        /* cancel the current workq request, without the mutex lock */
        edac_device_workq_teardown(edac_dev);

        /* acquire the mutex before doing the workq setup */
        mutex_lock(&amp;device_ctls_mutex);

        /* restart the workq request, with new delay value */
        edac_device_workq_setup(edac_dev, value);

    ...

}</ВЕРИФИКАЦИЯ>
<ВЕРТИП>Частный случай правила ID 0039</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование флага атомарного выделения памяти GFP_ATOMIC в не требующего этого контексте</Имя>
<ID>0051</ID>
<НАЗНАЧЕНИЕ>По своей сути операция выделения памяти (осуществляемая, например, функциями alloc_pages(), __get_free_pages() и т.д.) - блокирующая операция, которая может переводить процесс в режим сна, на время ожидания, скажем, освобождения памяти другой подсистемой ядра.
Однако, в случае написания асинхронных callback-процедур (обработчиков прерываний) переход в режим ожидания не допустим, так как данный обработчик не является процессом или нитью ядра, что не позволяет его повторное планирование на выполнение. В данном контексте необходимо осуществлять атомарное выделение памяти, которое производится передачей флага GFP_ATOMIC функциям подсистемы управления памятью.
Такого рода выделение памяти требует наличия запрошенного блока памяти &quot;здесь и сейчас&quot;, что негативно сказывается на вероятности положительного результата операции. В связи с этим, использование данного метода без видимой причины (т.е. вне контекста обработчика прерывания) может негативно сказаться на работе системы.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/scsi/aic7xxx_old.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg16759.html

drivers/messКАТЕГОРИЯ:АРХИТЕКТУРАage/i2o/device.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg16758.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.23 -&gt; drivers/scsi/aic7xxx_old.c
2.6.23 -&gt; drivers/message/i2o/device.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Необходимо явно отслеживать контекст выполнения каждой процедуры модуля. Требуется выделить ряд функций регистрации обработчиков прерываний (или callback процедур вызываемых из контекста прерываний); они в свою очередь передают атрибут &quot;контекс прерывания&quot; всем функциям, которые были зарегистрированы с их использованием. Только в такого рода функциях допустимо использование флага атомарного выделения памяти GFP_ATOMIC; из остальных функций использование данного флага необходимо рекомендовать исключить

drivers/message/i2o/device.c:

int i2o_parm_field_get(struct i2o_device *i2o_dev, int group, int field)
/* Данная функция никогда не вызывается из контекста прерывания*/
{
        u8 *resblk;             /* 8 bytes for header */
        int rc;

        resblk = kmalloc(buflen + 8, GFP_KERNEL | GFP_ATOMIC); /* Флаг GFP_ATOMIC излишен */

        if (!resblk)
                return -ENOMEM;

    ...
}

Преобразуем функцию в неатомарную:

int i2o_parm_field_get(struct i2o_device *i2o_dev, int group, int field)
/* Данная функция никогда не вызывается из контекста прерывания*/
{
        u8 *resblk;             /* 8 bytes for header */
        int rc;

        resblk = kmalloc(buflen + 8, GFP_KERNEL ); /* Убран флаг GFP_ATOMIC */

        if (!resblk)
                return -ENOMEM;

    ...
}</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ФЛАГИ УПРАВЛЕНИЯ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
! КОНТЕКСТ:ПРЕРЫВАНИЕ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ КОНТЕКСТОМ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Поиск недостижимых участков кода при обработке критических ситуаций</Имя>
<ID>0052</ID>
<НАЗНАЧЕНИЕ>Наиболее просто продемонстрировать применение правила на следующем участке кода подсистемы управления IDE устройствами:

drivers/ide/ide-taskfile.c

 static u8 wait_drive_not_busy(ide_drive_t *drive)
 {
         ...

    while (((stat = hwif-&gt;INB(IDE_STATUS_REG)) &amp; BUSY_STAT) &amp;&amp; retries--)
       udelay(10);

    if (!retries)
       printk(KERN_ERR &quot;%s: drive still BUSY!\n&quot;, drive-&gt;name);

    return stat;
 }

Исходное назначение данного функционального блока - ожидание освобождения некоторого устройства (получение текущего состояния объекта производится путем считывания значения одного из предоставляемых устройством регистров, используя вызов функции работы с портами ввода-вывода (INB)).
В случае, если функции не удалось дождаться освобождения объекта, происходит вывод отладочного сообщения и возврат управления вызывающей процедуре.
Однако, значение переменной `retries` при невозможности получения доступа к устройству будет равным `-1`, поэтому вывод отладочного сообщения произведен не будет.
В то же время данное сообщение будет отображено, при корректной работе процедуры, в том случае, если освобождение устройства произошло в момент, когда значением переменной retries была `1`. Тогда на следующем шаге retries-- -&gt; retries == 0.

На первый взгляд кажется, что данный пример имеет чисто логическую проблему, которая никакими средствами автоматизированного анализа выявлена быть не может (в первую очередь потому что имеет место событийность со стороны некоторого удаленного объекта - т.е. volatile эффект).

С другой стороны, предлагаю временно данный volatile эффект не учитывать, т.е. считать значение выражения `((stat = hwif-&gt;INB(IDE_STATUS_REG)) &amp; BUSY_STAT)` константным, причем != 0. В этом случае, если цикл `while` был завершен, то значение переменной `retries` равно -1 и средства статического анализа способны выявить недостижимый участок кода.

Несмотря на кажущуюся надуманность метода проверки, можно отметить, что он способен отлавливать т.н. `граничные ситуации`, которые встречаются довольно часто в разнообразных ожидающих событийных процедурах.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/ide/ide-taskfile.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg15044.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.22 -&gt; drivers/ide/ide-taskfile.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Некорректный участок кода, приведенный в описании правила в версиях 2.6.22+ был заменен на вариант, не содержащий данной проблемы:

for (retries = 0; retries &lt; 100; retries++)
{
   if ((stat = hwif-&gt;INB(IDE_STATUS_REG)) &amp; BUSY_STAT)
      udelay(10);
   else
      break;
}

!!! Предлагается проанализировать данное правило на возможность применения, с использованием каких-либо более сложных стандартных методов статического анализа, а также оценить корректность предложенного метода верификации.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Запрет прямого обращения к полю `private` структуры struct input_dev</Имя>
<ID>0053</ID>
<НАЗНАЧЕНИЕ>За последнее время появился ряд концептуальных подходов к структурам данных ядра. В первую очередь следует выделить попытку `эмуляции` закрытых для прямого доступа полей классов C++ (private/protected). К сожалению, отслеживать выполнение данных обязательств с использование атрибутов gcc в настоящий момент не представляется возможным, поэтому требование контролировать корректность доступа ложится на плечи разработчика модулей ядра.

Приведем пример определения структуры с явным задание мета-модификаторов доступа:

include/linux/input.h

struct input_dev
{
   /* private: */
   void *private;  /* do not use */

   /* public: */
   const char *name;
   const char *phys;
   const char *uniq;
   struct input_id id

        ...
}

Вследствие данного правила, запрещен прямой доступ к полю `private` данной структуры.
Необходимо использовать специализированные функции для работы с `закрытыми` полями специализированных системных структур.
В данном случае применяются следующие функции:

void *input_get_drvdata(struct input_dev *dev) -&gt; применяется для получения private-поля

input_set_drvdata(struct input_dev *, void *ts) -&gt; применяется для установки значения private-поля

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/input/mice/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10588.html

drivers/input/touchscreen/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10589.html

drivers/input/joystick/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10590.html

drivers/input/keyboard/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10591.html

drivers/input/misc/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10592.html

drivers/usb/input/*
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg10593.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.22 -&gt; drivers/input/mice/*

2.6.22 -&gt; drivers/input/touchscreen/*

2.6.22 -&gt; drivers/input/joystick/*

2.6.22 -&gt; drivers/input/keyboard/*

2.6.22 -&gt; drivers/input/misc/*

2.6.22 -&gt; drivers/usb/input/*</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

drivers/usb/input/acecad.c

static int usb_acecad_open(struct input_dev *dev)
{
    struct usb_acecad *acecad = dev-&gt;private; /* Проведение запрещенной операции обращения  */

    acecad-&gt;irq-&gt;dev = acecad-&gt;usbdev;
    if (usb_submit_urb(acecad-&gt;irq, GFP_KERNEL))
    {

    ...
}

Корректная версия метода (2.6.22+):

static int usb_acecad_open(struct input_dev *dev)
{
    struct usb_acecad *acecad = input_get_drvdata(dev); /* Корректное обращение к закрытому полю  */

    acecad-&gt;irq-&gt;dev = acecad-&gt;usbdev;
    if (usb_submit_urb(acecad-&gt;irq, GFP_KERNEL))
    {

    ...

}

Существует две методики проверки факта соблюдения данного правила:

* Метод явного наименования закрытых полей структур
Вследствие того, что закрытые поля вводятся исключительно в базовых системных структурах и, кроме того, их добавление носит инкрементальный характер (т.е. поля, никогда не теряют своего `private` статуса), возможно составление актуального списка полей, требующих специализированного метода обращения. Недостатком, как обычно, является большой объем ресурсов, требуемый для хранения данной информации.

* Метод эвристического обнаружения закрытых полей структур
Возможен полный анализ файлов заголовков ядра с целью составления текущего списка закрытых полей. Трудность состоит в том, что еще не выработан какой-либо устойчивый механизм обозначения закрытых полей. В большинстве своем применяется механизм `/* private: */` комментариев, но он не единственный возможный.
Автором предлагается использование расширенных сигнатур для поиска комментариев, определяющих класс доступа полей, с последующим дополнительным оповещением разработчика в ситуациях-неопределенностях.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование расширенного метода инициализации переменных spin-блокировки</Имя>
<ID>0054</ID>
<НАЗНАЧЕНИЕ>Одной из наиболее значимых проблем современного ядра Linux являются разнообразные dead-блокировки, которые постепенно проявляются все сильнее с появлением многопроцессорных архитектур, которые с большей вероятностью выявляют проблемы гранулированных блокировок. Поэтому было принято решение о введении специализированного механизма отладки такого рода критических ситуаций. С введением данных средств становится возможным отследить во времени захват той или иной блокировки конкретным модулем операционной системы и, соответственно, ее освобождение. Это позволяет проводить анализ ситуаций возникновкения взаимноблокировок и дальнейшее их устранение.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/atm/atmtcp.c
net/atm/clip.c
net/atm/lec.c
net/atm/mpc.c
net/atm/signaling.c
net/dccp/minisocks.c
net/ipv6/mip6.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg09137.html

drivers/s390/char/vmlogrdr.c
drivers/s390/cio/cmf.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg08734.html

Введение расширенных механизмов потребовало введения дополнительных полей структуры spinlock_t (естественно исключительно при сборке ядра со включенной опцией CONFIG_DEBUG_SPINLOCK). В свою очередь это повлекло невозможность инициализации данной структуры методами, применявшимися ранее, которые по своей сути осуществляли обычное атомарное присвоение значения блокирующей переменной. Теперь структура блокировки стала гораздо сложнее и включает множество полей:

typedef struct
{
   raw_spinlock_t raw_lock;

#if defined(CONFIG_PREEMPT) &amp;&amp; defined(CONFIG_SMP)
   unsigned int break_lock;
#endif

#ifdef CONFIG_DEBUG_SPINLOCK  /* Отладочная информация */
   unsigned int magic, owner_cpu;
   void *owner;
#endif

#ifdef CONFIG_DEBUG_LOCK_ALLOC /* Отладочная информация */
   struct lockdep_map dep_map;
#endif
} spinlock_t

Соответственно инициализация блокировки притерпела изменения и теперь производится следующим образом:

drivers/atm/atmtcp.c

static struct atm_dev atmarpd_dev =
{
  .ops =                  &amp;atmarpd_dev_ops,
  .type =                 &quot;arpd&quot;,
  .number =               999,
  .lock =                 __SPIN_LOCK_UNLOCKED(atmarpd_dev.lock) /* Инициализация нового типа */
};

Отличием является использование макроса __SPIN_LOCK_UNLOCKED(lock) вместо SPIN_LOCK_UNLOCKED. Параметризация введена для фиксирования конкретного объекта блокировки (например, имя модуля + имя структуры).</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.22 -&gt; drivers/atm/atmtcp.c

2.6.22 -&gt; net/atm/clip.c

2.6.22 -&gt; net/atm/lec.c

2.6.22 -&gt; net/atm/mpc.c

2.6.22 -&gt; net/atm/signaling.c

2.6.22 -&gt; net/dccp/minisocks.c

2.6.22 -&gt; net/ipv6/mip6.c

2.6.22 -&gt; drivers/s390/char/vmlogrdr.c

2.6.22 -&gt; drivers/s390/cio/cmf.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

Требуется обнаруживать все вхождения вида

ПЕРЕМЕННАЯ_ТИПА_spinlock_t = SPIN_LOCK_UNLOCKED;

и рекомендовать разработчику использовать расширенные средства инициализации блокировок вида:

ПЕРЕМЕННАЯ_ТИПА_spinlock_t = __SPIN_LOCK_UNLOCKED(ПЕРЕМЕННАЯ_ТИПА_spinlock_t);

drivers/s390/char/vmlogrdr.c:

/* Устревшая методика инииализации */

static struct vmlogrdr_priv_t sys_ser[] =
{
   .recording_name = &quot;EREP&quot;,
   .minor_num      = 0,
   .buffer_free    = 1,
   .priv_lock      = SPIN_LOCK_UNLOCKED,
   .autorecording  = 1,
   .autopurge      = 1,
}

/* Обновленная расширенная методика */

static struct vmlogrdr_priv_t sys_ser[] =
{
   .recording_name = &quot;EREP&quot;,
   .minor_num      = 0,
   .buffer_free    = 1,
   .priv_lock      = __SPIN_LOCK_UNLOCKED(sys_ser[0].priv_lock),
   .autorecording  = 1,
   .autopurge      = 1,
}</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Эвристический анализ использования внутримодульных мьютексов и семафоров</Имя>
<ID>0055</ID>
<НАЗНАЧЕНИЕ>По своей природе семафору требуется обеспечить реализацию блокируемого счетчика, т.е. сделать возможным расширение количества возможных состояний с двух (как у мьютексов) до ограниченного разрядностью счетчика. При этом становится возможным использование семафора в качестве разграничителя доступа типа `разрешен захват только n субъектам одновременно`. Это накладывает ряд ограничений на внутреннюю организации семафоров и делает их потенциальную эффективность значительно ниже, чем у мьютексов, которые могут находится только в `бинарном состоянии` захвачен/свободен.

Это вызывает ряд оптимизационных проблем. При написании модулей ядра разработчики часто пренебрегают возможностью мьютексов, используя так называемые `бинарные семафоры`, т.е. применяя семафоры в ситуациях, когда требуется иключительно бинарное состояние блокировки. Это никак не влияет на функциональные возможности полученного кода, но может служить причиной снижения производительности (особенно на архитектурах, представляющих аппаратную реализацию бинарных мьютексов, которая в этом случае игнорируется в пользу полноразмерных счетчиков).

Правило регламентирует использование `чистых` мьютексов для разграничения доступа к внутримодульным данным при отсутствии необходимости в одновременном использовании объекта блокировки со стороны неединичного числа субъектов. Следует отметить, что такого рода необходимость практически не встречается при разработке модулей-драйверов и присутствует в основном в базовом коде подсистем ядра для балансирования нагрузки на ряд определенных системных объектов.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:

drivers/base/attribute_container.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg09390.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:

2.6.22 -&gt; drivers/base/attribute_container.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:

drivers/base/attribute_container.c:

Неоптимальное применение `бинарных семафоров` в не требующем этого контексте

static struct list_head attribute_container_list;

static DECLARE_MUTEX(attribute_container_mutex); /* Инициализация семафора */

int attribute_container_unregister(struct attribute_container *cont)
{
   int retval = -EBUSY;
   down(&amp;attribute_container_mutex);  /* Захват блокировки */

   spin_lock(&amp;cont-&gt;containers.k_lock);
   if (!list_empty(&amp;cont-&gt;containers.k_list))
       goto out;

       ...

   list_del(&amp;cont-&gt;node);

   out:
   spin_unlock(&amp;cont-&gt;containers.k_lock);

   up(&amp;attribute_container_mutex); /* Освобождение блокировки */

   return retval;

}

В данном контексте семафор используется в роли мьютекса, ограничивая одновременный доступ к разделяемому ресурсу `attribute_container_list`. Причем очевидна `бинарность` его состояний.

Уместно рекомендовать использование `чистых` мьютексов для максимальной возможной оптимизации вычислительного процесса:

static struct list_head attribute_container_list;

static DEFINE_MUTEX(attribute_container_mutex); /* Инициализация `чистого` мьютекса */

int attribute_container_unregister(struct attribute_container *cont)
{
   int retval = -EBUSY;
   mutex_lock(&amp;attribute_container_mutex);  /* Захват блокировки */

   spin_lock(&amp;cont-&gt;containers.k_lock);
   if (!list_empty(&amp;cont-&gt;containers.k_list))
       goto out;

       ...

   list_del(&amp;cont-&gt;node);

   out:
   spin_unlock(&amp;cont-&gt;containers.k_lock);

   mutex_unlock(&amp;attribute_container_mutex); /* Освобождение блокировки */

   return retval;

}

Возможно два подхода для выявления подобных ситуаций:

* Обнаружение всех используемых внутримодульных семафоров и оповещение разработчика на уровне WARNING о возможной ошибке. Данная методика проверки актуальна в связи с тем, что практика использования полных семафоров в коде драйверов чрезвычайна мала, в противовес мьютексам и spin-блокировкам.

* Эвристическое выявление `бинарного` свойства блокировки на основе ее использования в коде модуля ядра. При этом следует учитывать возможность вызова некоторых функций модуля асинхронно (например при регистрации в качестве callback-вызовов).

С точки зрения автора, первый вариант обнаружения является наиболее оптимальным по соотношению качество обнаружения/трудозатраты. С другой стороны, следует проанализировать возможность обнаружения данного свойства блокировки &quot;дешевым методом&quot;, т.е. используя какие-либо стандартные возможности разрабатываемого средства, реализация которых требуется рядом других правил.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Попытка применения функции освобождения памяти kfree(...) к данным, расположенным в области стека</Имя>
<ID>0056</ID>
<НАЗНАЧЕНИЕ>Данная ошибка возникает из-за некорректной трактовки поведения ряда функций пакета работы с символьными строками (linux/lib/string.c). Например, во многих случаях разработчик, используя стандартную функцию strsep(...) (которая осуществляет выделение части строки, ограниченной символом-разделителем), ожидает получить в качествев возвращаемого значения указатель на подстроку в выделенной из системной кучи памяти.

Основываясь на поведении некоторых аналогичных функций, считается что данный вызов должен осуществить выделение дополнительной памяти (используя kmalloc(...)), скопировать найденную подстроку исходных данных и только после этого осуществить возврат управления.

В то же время kernel-версия функции strsep устроена иначе. Ее реализация предусматривает возможность модификации переданной исходной строки (а также указателя на нее, в целях упрощения циклического поиска всех доступных подстрок). Это позволяет не затрачивать дополнительные ресурсы на выделение памяти, а предоставлять в качестве результата выполнения - указатель на исходную строку (модифицированную вставкой \0 символа вместо первого вхождениян найденного разделителя).

Это приводит к труднообнаружимой проблеме, связанной с попыткой освобождения (используя kfree(...)) области памяти по указателю, полученному в качестве возвращаемого значения из функции strsep(...) и ей подобных.

Возможным продолжением данной проблемы может стать попытка вторичного освобождения памяти, основанная на том же факте неверной трактовки механизма работы представленных функций. В этом случае первичное освобождение может производиться с использованием указателя, полученного от одной из &quot;библиотечных&quot; функций (обычно после
проведения ряда операций с результатом работы того или иного метода), вторичное же последует в момент групповой очистки использованной памяти (например, в конце того или иного блока кода).

Распространена аналогичная ошибка, порожденная сменой метода выделения памяти для тех или иных системных переменных. Это связано с попыткой максимального использования стековой памяти против данных
алоцированных в &quot;куче&quot; (что позволяет получить небольшой выигрыш в пиковом объеме свободной памяти и снизить вероятность её утечек).

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:
drivers/mtd/devices/block2mtd.c
http://kerneltrap.org/mailarchive/git-commits-head/2008/3/25/1247394</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/mtd/devices/block2mtd.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:
drivers/mtd/devices/block2mtd.c:
static int
block2mtd_setup2(const char *val)
{
char buf[80 + 12]; /* выделение области памяти размером 92 байта на вершине стека */
char *str = buf;
char *token[2];
char *name;
size_t erase_size = PAGE_SIZE;
int i, ret;
/* ... */
for (i = 0; i &lt; 2; i++)
/* Получение ряда указателей на различные участки вышеозначенной области стека */
/* Содержимое массива buf притерпело некоторые изменения в связи с исполнением */
/* функции strsep, но само расположение данных осталось неизменным */
token[i] = strsep(&amp;str, &quot;,&quot;);
/* ... */
name = token[0];
/* ... */
if (token[1])
{
ret = parse_num(&amp;erase_size, token[1]);
if (ret)
{ /* При обнаружении ошибки на этапе разбора строки входных параметров */
/* происходит попытка некорректного освобождения области данных, */
/* расположенной в стеке. В данном случае поведение системы абсолютно */
/* непредсказуемо; если по стечению обстоятельств содержимое стека */
/* будет иметь форму специализированных заголовков подсистемы управления */
/* памятью, это может привести к фатальным для всего ядра ОС последствиям. */
/* Корректный вариант данной строки не содержит */
kfree(name);
parse_err(&quot;illegal erase size&quot;);
}
}
/* ... */
}
Следует отметить повышенную сложность обнаружения данной ошибки
стандартными методами тестирования. Это связано с рядом факторов:
 ошибка может возникнуть только при попадании в обработчик
исключительной ситуации
 ошибка может как пройти незамеченной для функционирующей
системы (в случае корректной отработки механизмов контроля
сигнатур участков кучи), так и полностью вывести ее из cтроя (при
обнаружении данных определенного вида в выделенной области стека)
С точки зрения автора данная ошибка является во-многом типичной и
олицетворяет собой целый ряд подобных проблем ядра Linux.
Её выявление следует осуществлять на базе схемы привязки ряда
специализированных атрибутов к каждому объекту-переменной. В данном
случае возможно отслеживание одновременно двух типов &quot;событий&quot;:
 Попытка передачи функции kfree (...) переменной, одним из свойств
которой является ассоциированный атрибут &quot;расположение в стеке&quot;. В
такой трактовке методика проверки полностью отражает содержание
вышеозначенного правила.
 Попытка передачи функции kfree (...) переменной, НЕ обладающей
ассоциированным атрибутом &quot;динамическое выделение в куче&quot;.
Данная проверка является более общей и частично покрывает ряд уже
предложенных правил, но в то же время позволяет выдавать
обоснованные предупреждения в случае невозможности
гарантированной привязки означенного атрибута к переменной.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ. Safety</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Утечки памяти</Имя>
<ID>0057</ID>
<НАЗНАЧЕНИЕ>---------------------------------------------------------
1.
---------------------------------------------------------
Предотвращение (на уровне предупреждений) ряда `явных` утечек памяти
Отслеживание связи по данным с вышележащими компонентами ОС
---------------------------------------------------------

С увеличением объема кода драйвера все сложнее следить за корректным освобождением всей выделенной памяти (следует также учитывать необходить проводить порционные очистки при обнаружении исключительных ситуаций и т.д.)
В то же время для автоматизированного средства контроль за соблюдением ряда простейших правил особой сложности не составит, предотвратив тем не менее группу опасных и трудновыявимых проблем ядра.

Наиболее удобно продемонстрировать одну из проблем и методику ее решения на живом примере кода ядра Linux:
/drivers/pci/hotplug/ibmphp_ebda.c:
static int __init
ebda_rsrc_controller (void)
{
/* ... */
/* Пространство под указатель выделено на вершине стека - */
/* время жизни переменной ограничего пределами функционального */
/* блока */
struct slot *tmp_slot;
/* ... */
for (...)
{
tmp_slot = kzalloc(sizeof(*tmp_slot), GFP_KERNEL);
if (!tmp_slot)
{
rc = -ENOMEM;
goto error_no_slot;
}
/* Сложная процедура задания значения полей выделенной в куче структуры */
/* Примером одной из операций может служить: */
if ((hpc_ptr-&gt;slots[index].slot_cap &amp; EBDA_SLOT_133_MAX) == EBDA_SLOT_133_MAX)
tmp_slot-&gt;supported_speed = 3;
else if ((hpc_ptr-&gt;slots[index].slot_cap &amp; EBDA_SLOT_100_MAX) == EBDA_SLOT_100_MAX)
tmp_slot-&gt;supported_speed = 2;
/* Отметим тот факт, что передача какой либо информации происходит лишь в направлении */
/* к переменной tmp_slot. Указатель на нее или непосредственное значение никаким */
/* сторонним объектам не передается */
if (!bus_info_ptr1)
{
rc = -ENODEV;
/* Принудительный переход на завершающий обработчик исключительной ситуации */
goto error; /* 1 */
}
/* ... */
/* Первый случай передачи информации со стороны переменной tmp_slot */
hp_slot_ptr-&gt;private = tmp_slot;
hp_slot_ptr-&gt;release = release_slot;
/* ... */
rc = fillslotinfo(hp_slot_ptr);
if (rc)
goto error; /* 2 */
rc = ibmphp_init_devno ((struct slot **) &amp;hp_slot_ptr-&gt;private);
if (rc)
goto error; /* 2 */
/* ... */
}
error:
/* На момент перехода из участка 1 (см. выше) функции kfree будет передан */
/* нулевой указатель, что повлечет за собой корректный возврат управления */
/* 3 */
kfree (hp_slot_ptr-&gt;private);
}

Отметим важную особенность данного кода. Попадание в точку /* 3 */ допускается из двух неравноценных ситуаций:

- Cитуация /* 1 */ - поле hp_slot_ptr-&gt;private еще не содержит корректного указателя (его место занимает нулевой). Для проведения корректной очистки нужно осуществлять передачу в качестве параметра функции kfree (...) непосредственно значения указателя tmp_slot. Сделать это явно невозможно в связи с наличием ситуации передачи управления /* 2 */

- Ситуация /* 2 */ - в момент перехода, значение переменой tmp_slot уже было использовано в качестве параметра интерфейса взаимодействия с вышележащими слоями ОС, поэтому осуществлять явное освобождение памяти на которую указывает tmp_slot в обработчике `error` запрещено. Это связано с высокой вероятностью попытки разыменования данного указателя со стороны одного из вышележащих модулей.

ССЫЛКА НА ОРИГИНАЛ LKLM-СООБЩЕНИЯ:
/drivers/pci/hotplug/ibmphp_ebda.c:
http://marc.info/?l=git-commits-head&amp;m=120520082818287&amp;w=4

---------------------------------------------------------
2.
---------------------------------------------------------
Утечки памяти, связанные с игнорированием требования освобождения динамически выделяемых регионов
---------------------------------------------------------
2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=093a44e71aa29157fb1611b00507d67c954099d6

drivers/isdn/sc/ioctl.c:

@@ 218

spid = kmalloc(SCIOC_SPIDSIZE, GFP_KERNEL);

@@ 226

if (copy_from_user(spid, data-&gt;dataptr, SCIOC_SPIDSIZE)) {
   kfree(rcvmsg);
   /* необходимо освободить выделенные регион
      памяти перед возвратом из функции       */
   kfree(spid);
   return -EFAULT;
}</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; /drivers/pci/hotplug/ibmphp_ebda.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>МЕТОДИКА ОБНАРУЖЕНИЯ:
Требуемое от средства верификации поведение:

- Отобразить предупреждение о возможной утечке памяти, основываясь на наличии маршрута, в процессепрохода по которому значение переменной-указателя tmp_slot теряется (в то время как явное освобождение памяти отсутствует).

- Важным моментом является требование отсутствия передачи какой либо информации со стороны объекта в иные слои ОС (это в большинстве случаев аргумент в пользу игнорирования требований по очистке памяти вследствие того, что соответствующий kfree-вызов будет проведен вышележащим слоем).

- Корректным должен считаться код, проводящий требуемое на участке /* 1 */ освобождение памяти непосредственно в том же блоке, до осуществления перехода на единый обработчик исключительных ситуаций `error`.
if (!bus_info_ptr1)
{
kfree (tmp_slot);
rc = -ENODEV;
/* Принудительный переход на завершающий обработчик исключительной ситуации */
goto error; /* 1 */
}

- [ТРЕБУЕТ ДОРАБОТКИ] Необходимо каким-либо способом реагировать на попытку освобождения памяти по указателю, значение которого ранее было передано иным слоям/подсистемам ядра. Часто такого рода поведение является ошибочным (потому как неявно подразумевается что переданный указатель будет использован вышележащим модулем)!</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ. Safety (в общем случае liveness)</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_WARNING item="y">
<Имя>Динамическое выделение памяти под специализированные коллекции объектов типа `kobject` (kset)</Имя>
<ID>0058</ID>
<НАЗНАЧЕНИЕ>В целях построения некоторой иерархического структуры, отражающей отношения, существующие между теми или иными объектами ядра Linux (например, драйверами, доступными шинами, устройствами или системными структурами данных) была разработана и внедрена технология т.н. ядровых объектов.

Технология kobject представляет собой совокупность гетерогенных системных сущностей, каждая из которых находится на своей жестко определенной нише абстракции:

kobject - сущность самого нижнего уровня иерархии.
Обычно объект данного типа встраивается в системные структуры данных драйверов (например в структуру содержащую информацию о привязанном к драйверу физическом устройстве) и позволяет во-первых реализовать счетчик обращений (с использованием методов kobject_get/kobject_put), а во-вторых отразить наличие данной сущности в информационно-
конфигурационной псевдо-ФС sysfs.

kset - коллекция объектов типа kobject Позволяет проводить некоторую смысловую группировку объектов,
основываясь на общих для них свойствах. Обычно ядровые объекты принадлежащие одной коллекции kset имеет
одинаковое значение параметра kobj_type который характеризует такие свойства сущности, как методы &quot;конструирования&quot;, &quot;деструкции&quot; и обращения со стороны sysfs.
Если сущность kobject по своей природе является динамической (это связано с наличием свойства автоматического освобождения занимаемой памяти при достижении счетчиком ссылок kref нулевого значения), то
относительно коллекций kset изначально было принято противоположенное решение - реализовать их исключительно в виде статически выделенных областей памяти.
В первую очередь это было связано с тем, что общее количество такого рода сущностей в системе невелико и обычно ограничивается 30-50 (в это число входят все системные шины + доступные классы устройств + абстрактные
объединения тех или иных объектов). Поэтому введение специализированных методов аллокации такого рода данных было на первых этапах нецелесообразным.
В настоящее время точка зрения на `kset` постепенно меняется. Теперь это уже не некое подобие описателя подсистемы ядра - это малоемкий контейнер, который позволяет проводить более четкую и точную классификацию и группировку ядровых сущностей.
В связи с этим количество таких объектов резко возросло, что пагубно сказывается на расходе оперативной памяти при ее статическом выделения под данные объектов `kset`.
Версия ядра 2.6.25 снабжена полноценными средствами динамической аллокации областей памяти для объектов типа `kset`. Это повлекло за собой признание ранее использованных статических методов выделения памяти под объекты kset устаревшими (deprecated) и потребовало постепенного перевода всей существующей кодовой базы на новые интерфейсы управления подсистемой kobject.

ССЫЛКА НА ОРИГИНАЛ LKLM-СООБЩЕНИЯ:
drivers/base/firmware.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg32516.html
drivers/base/class.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg32554.html
drivers/base/bus.c
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg32517.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/base/firmware.c
2.6.25 -&gt; drivers/base/class.c
2.6.25 -&gt; drivers/base/bus.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:
Новый интерфейс динамического выделения памяти под объекты `kset`
представлен следующими функциями:
struct kset *
kset_create_and_add(const char *name, struct kset_uevent_ops *uevent_ops, struct kobject *parent_kobj);
void
kset_unregister(struct kset *k);
Приведем пример ранее применявшегося метода статического выделения
памяти:
drivers/base/bus.c (&lt; 2.6.25):
/* Макрос, разворачивающийся в статическое создание переменной типа struct kset */
#define decl_subsys(_name,_type,_uevent_ops) \
struct kset _name##_subsys = { \
.kobj = { .k_name = __stringify(_name) }, \
.ktype = _type, \
.uevent_ops =_uevent_ops, \
}
/* Статическая аллокация коллекции &quot;системные шины&quot; */
static decl_subsys(bus, &amp;bus_uevent_ops);
int bus_register(struct bus_type * bus)
{
/* Работа с адресом статически выделенной памяти */
bus-&gt;subsys.kobj.kset = &amp;bus_subsys;
bus-&gt;subsys.kobj.ktype = &amp;bus_ktype;
/* Регистрация коллекции */
retval = subsystem_register(&amp;bus-&gt;subsys);
/* ... */
}
i
nt __init buses_init(void)
{
/* Регистрация коллекции */
return subsystem_register(&amp;bus_subsys);
}
Теперь осуществим переход к новому интерфейсу динамического выделения
памяти на примере того же драйвера, но уже версии, включенной в ядро
2.6.25:
static struct kset *bus_kset;
int bus_register(struct bus_type * bus)
{
/* Передача указателя на динамически выделенную область памяти */
bus-&gt;subsys.kobj.kset = bus_kset;
bus-&gt;subsys.kobj.ktype = &amp;bus_ktype;
/* ... */
retval = subsystem_register(&amp;bus-&gt;subsys);
}
int __init buses_init(void)
{
/* Динамическое выделение памяти под структуру `kset` */
bus_kset = kset_create_and_add(&quot;bus&quot;, &amp;bus_uevent_ops, NULL);
if (!bus_kset)
return -ENOMEM;
return 0;
}
Средство верификации должно осуществлять проверку атрибута области памяти, которую адресует указатель *.kobj.kset некой структуры, в которую встроен объект типа kobject. Данный проверяемый атрибут должен явно
разделять статически и динамически выделенные области памяти. Если настоящий указатель адресует статически выделенную память, следует выдать предупреждение об использовании `deprecated` интерфейса и
предложить использовать расширенный метод выделения памяти для такого рода объектов.
Эта методика позволяет игнорировать случаи создания kset-коллекций статически для целей отличных от явного внедрения в sysfs. В случае, если такой дифференциации случаев статической аллокации kset
не требуется - достаточно сообщать о некорректном поведении при попытке создать объект kset любым методом отличным от вызова специализированной процедуры описанной выше.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ/РС</ВЕРТИП>
<ПРИМЕЧАНИЯ>deprecated макрос decl_subsys, функция subsystem_register</ПРИМЕЧАНИЯ>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Применение специализированных механизмов `packet processing NAPI` только при наличии соответствующей поддержки со стороны программно-аппаратной платформы</Имя>
<ID>0059</ID>
<НАЗНАЧЕНИЕ>В ходе накопления опыта использования ОС Linux на
сверхвысокопроизводительном сетевом оборудовании была выявлена
серьезная проблема, называемая &quot;усталостью от прерываний сетевой
подсистемы&quot;.
Типичный подход к организации низкоуровневой драйверо-ориентированной
(MII/PHY) части сетевого стека Linux заключается в построение сложного
обработчика прерываний контролируемого сетевого устройства.
Условно, можно описать каркас такого рода драйвера в виде:
static irqreturn_t
fs_enet_interrupt(int irq, void *dev_id)
{
/* Сложные процедуры обработки входящих данных */
/* Время задержки велико */
/* Отправка полученных от ведомого устройства
данных в верхние слои сетевой подсистемы */
netif_receive_skb(skb);
}
Несмотря на всю простоту такого рода решения, легко обнаружить, что в
нагруженной сетевой среде (а в особенности при использовании целого ряда
сетевых контроллеров под управлением одной операционной системы)
прерывания о получении новых информационных пакетов могут приходить
настолько часто, что постоянные переключения на РЕСУРСОЕМКИЕ
обработчики могут резко снизить общую производительность системы.
Разработчиками NAPI (new API) было предложено решение, во много
аналогичное технологическому подходу &quot;нижних половин
прерываний&quot; (bottom half handlers). Оно заключается в создании
сверхбыстрых обработчиков прерываний, которые осуществляют лишь
добавление контролируемого устройства в список опроса ОС.
Предположим, что устройство А получило новый сетевой пакет, о чем ОС
была проинформирована путем аппаратного прерывания. Обработчик
осуществляет размещение нового задания (&quot;получение данных от устройства
А&quot;) в очереди сетевой подсистемы. Вслед за этим он осуществляет
физическое отключение прерываний устройства А. Даже если оно будет
получать все новые и новые пакеты, никаких переходов на обработчики
прерываний совершаться не будет, т.к. устройство уже есть в списке
ожидания. Когда очередь доходит до задания, касающегося устройства А,
специализированные механизмы драйвера устройства осуществляют
извлечение ВСЕХ накопившихся пакетов данных и вновь включают
оповещение путем отправки прерывания. Таким образом ОС экономит
время, требуемое на множественные переключения контекста.
Однако возможность использования такого удобного средства обработки
предоставляется только на ряде аппаратных конфигураций, потому как
требует возможности реализации т.н. `DMA ring` (или наличия достаточно
большого количества памяти на борту сетевого устройства для хранения
групп пакетов) и, естественно, быстрого способа деактивации прерываний
устройства.
О том, возможно ли применение технологии NAPI на данной программно-
аппаратной платформе, драйвер извещается при передаче callback-probe-
функции указателя на информационную структуру `fs_platform_info` в
качестве одного из полей описателя обнаруженного устройства.
Описываемая структура содержит требуемую информацию в явном виде
((fs_platform_info*) fpi-&gt;use_napi).
В случае, если поддержки NAPI нет, драйвер должен использовать
стандартные методы контроля прерываний ведомого устройства и НЕ
ПЫТАТЬСЯ ИСПОЛЬЗОВАТЬ специализированные NAPI-процедуры и
функции. В большинстве случаев это будет лишь снижать общее время
обработки данных (так как любые вызовы расширенного API будут
отрабатывать вхолостую), однако же в ходе дальнейшей модификации кода
сетевой подсистемы возможны случаи, когда такого рода обращения могут
быть опасны.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:
drivers/net/fs_enet/fs_enet-main.c:
http://kerneltrap.org/mailarchive/git-commits-head/2008/4/14/1429514</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/net/fs_enet/fs_enet-main.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:
2.6.25 -&gt; drivers/net/fs_enet/fs_enet-main.c:
Данный код представляет собой реализацию драйвера Ethernet контроллера,
обслуживающего целую серию устройств фирмы Motorola.
Рассмотрим последовательно основные шаги инициализации и
функционирования драйвера.
Если одно из поддерживаемых устройств было обнаружено на системной
шине, вызывается callback-процедура probe() драйвера устройства, которая
проводит начальную инициализацию устройства и его регистрацию в
специализированных общесистемных списках ОС.
static int __devinit fs_enet_probe(struct device *dev)
{
struct net_device *ndev;
/* Проверка возможности обслуживания данного устройства */
/* Передачи данных функции инициализации устройства */
/* dev-&gt;platform_data - указатель на описанную информационную структуру типа
platform_info */
ndev = fs_init_instance(dev, dev-&gt;platform_data);
if (IS_ERR(ndev))
return PTR_ERR(ndev);
return 0;
}
Процедура оконечной инициализации fs_init_instance проводит ряд операций
по начальному конфигурированию устройства, а также сохраняет
переданную информационную структуру в дескрипторе сетевого
контроллера, для дальнейшего использования.
static struct net_device *fs_init_instance(struct device *dev,
struct fs_platform_info *fpi)
{
/* Конфигурирование устройства */
/* Формирование дескриптора сетевого контроллера */
fep-&gt;dev = dev;
dev_set_drvdata(dev, ndev);
/* Сохранение системной информации */
fep-&gt;fpi = fpi;
/* Регистрация обработчиков */
ndev-&gt;open = fs_enet_open;
/* ... */
ndev-&gt;stop = fs_enet_close;
/* Добавляем устройство в общесистемный список */
err = register_netdev(ndev);
}
После того, как ОС проинформирована о готовности устройства и его
драйвера к работе, возможна асинхронная передача управления callback-
процедурам модуля (например, при активации линии прерывания).
Данный драйвер применяет расширенный механизм обработчиков в стиле
NAPI (см. выше) с введением быстрых процедур реакции на прерывание.
Нам же интересен момент вызова со стороны ОС обработчика fs_enet_close().
Рассмотрим его НЕКОРРЕКТНУЮ реализацию:
drivers/net/fs_enet/fs_enet-main.c (&lt; 2.6.25):
static int fs_enet_close(struct net_device *dev)
{
struct fs_enet_private *fep = netdev_priv(dev);
unsigned long flags;
netif_stop_queue(dev);
/* Деактивация несущей */
netif_carrier_off(dev);
/* Деактивация компоненты NAPI */
/* ОТСУТСТВУЕТ ПРОВЕРКА ФАКТА ВОЗМОЖНОСТИ
ИСПОЛЬЗОВАНИЯ
РАСШИРЕННОГО NAPI ФУНКЦИОНАЛА */
napi_disable(&amp;fep-&gt;napi);
/* Останов элемента физического уровня */
phy_stop(fep-&gt;phydev);
/* Отключение различных компонентов контроллера */
return 0;
}
Осуществлять передачу управления подсистеме NAPI возможно лишь
убедившись в ее активность на данной платформе.
Корректно код можно переписать в виде:
static int fs_enet_close(struct net_device *dev)
{
struct fs_enet_private *fep = netdev_priv(dev);
unsigned long flags;
netif_stop_queue(dev);
/* Деактивация несущей */
netif_carrier_off(dev);
/* Деактивация компоненты NAPI */
/* Проверка наличия поддержки NAPI */
if (fep-&gt;fpi-&gt;use_napi)
napi_disable(&amp;fep-&gt;napi);
/* Останов элемента физического уровня */
phy_stop(fep-&gt;phydev);
/* Отключение различных компонентов контроллера */
return 0;
}
Обнаружение следует проводить, основываясь на факте достижимости
любого вызова NAPI без введения прямой или косвенной проверки
поддержки данного механизма.
Серьезно облегчает работу тот факт, что данная информация может быть
получена ТОЛЬКО описанным выше способом (с использованием поля
use_napi структуры fs_platform_info, передаваемой `probe`-функции
драйвера)</ВЕРИФИКАЦИЯ>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Запрет на добавление в связный список одной и той же сущности дважды</Имя>
<ID>0060</ID>
<НАЗНАЧЕНИЕ>Одной из наиболее распространенных структур хранения данных ядра
являются связные списки, формируемые набором макросов вида
LIST_HEAD() / INIT_LIST_HEAD ().
Основой функционирования данного способа представления данных
является структура
struct list_head
{
struct list_head *next, *prev;
};
которая явно включается в информационные структуры данных для
создания внутренних связей поддержки списка.
Рассмотрим данную методику на примере драйвера EFI-расширения DMI
(Direct Machine Interface), позволяющего получать важную
конфигурационную информацию непосредственно из адресного
пространства устройства на этапе начальной инициализации.
В данном случае результатом работы драйвера должен быть общесистемный
список устройств, которые предоставляют поддержку механизма DMI.
Элементами списка будут структуры-описатели такого рода устройств,
содержащие помимо имени устройства и его типа, дополнительные данные о
том, какая же информация может быть предоставлена.
Данная структура представлена в ядре в следующем виде:
struct dmi_device
{
struct list_head list;
int type;
const char *name;
void *device_data;
};
Как было сказано ранее, поле list (совокупность указателей next и prev)
данной структуры служит для установки связей между элементами списка.
Добавление нового элемента в связный список осуществляется с
использованием процедуры list_add()
static inline void __list_add(struct list_head *new,
struct list_head *prev,
struct list_head *next)
{
next-&gt;prev = new;
new-&gt;next = next; /* 1 */
new-&gt;prev = prev; /* 2 */
prev-&gt;next = new;
}
static inline void list_add(struct list_head *new, struct list_head *head)
{
__list_add(new, head, head-&gt;next);
}
Параметр new представляет собой указатель на поле list той структуры,
добавление которой следует провести;
head - указатель на текущий головной элемент списка, после которого
следует новый элемент разместить.
Особенно следует обратить внимание на строки /* 1 */ и /* 2 */ в которых
осуществляется модификация полей связи добавляемого элемента. После
проведения данной операции становится возможным применение остальных
механизмов работы со списком (например, циклического перебора всех его
элементов).
Представим, что экземляр структуры dmi_device входит в некоторый список
dmi_devices. В этом случае его поля list.next и list.prev содержат указатели
на соседние элементы этого списка, в свою очередь также ссылающиеся
(только односторонне) на этот элемент.
Теперь попробуем провести добавление этого экземляра в список еще раз.
Означенная выше операция __list_add() осуществит переопределение
значений полей list.next и list.prev этого элемента, тем самым нарушив
прошлую связь элемента (в прошлом соседние элементы все еще указывают
на модифицируемый). В данном случае операция перебора всех элементов
списка может никогда не завершиться, так как будет создана некоторая
циклическая цепочка связей:
Пусть изначально список был представим в виде
-&gt; a &lt;-&gt; b &lt;-&gt; c &lt;-&gt; d &lt;-&gt;e &lt;-
Добавим элемент `c` сразу за элементом `a`
-&gt; a &lt;-&gt; c &lt;-&gt; b -&gt; c { &lt;-&gt; b } &lt;- d &lt;-
`{ }` обозначена появившаяся связь элемента c, после его повторного
добавления в список
Теперь попытаемся провести циклический перебор элементов списка с его
вершины в `a`:
a c (b c) =&gt; такого рода проход превращается в бесконечный цикл.
Поэтому повторное добавление сущности в список является недопустимой (и
в то же время трудновыявимой) операцией.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:
drivers/firmware/dmi_scan.c:
http://www.mail-archive.com/git-commits-head@vger.kernel.org/msg41536.html</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/firmware/dmi_scan.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:
2.6.25 -&gt; drivers/firmware/dmi_scan.c:
Рассмотрим основные этапы функционирования данного драйвера
поддержки DMI:
void __init dmi_scan_machine(void)
{
/* ... */
if (efi_enabled)
{
/* Необходима поддержка EFI BIOS для возможности использования DMI */
/* Осуществим отображение пространства ввода - вывода устройств на некоторые
страницы памяти ядра */
p = dmi_ioremap(efi.smbios, 32);
if (p == NULL)
goto out;
/* Если предварительные операции прошли успешно - начинаем проверку
поддержки расширения DMI */
rc = dmi_present(p + 0x10); /* offset of _DMI_ string */
dmi_iounmap(p, 32);
if (!rc)
{
dmi_available = 1;
return;
}
}
else
{
/* ... */
}
}
out: printk(KERN_INFO &quot;DMI not present or invalid.\n&quot;);
}
Основной задачей функции является проверка наличия среды
инициализации EFI BIOS конкретной машины.
Если такого рода среда используется - осуществляется отображение адресов
пространства ввода-вывода на страницы памяти ядра. Это делается для
удобства дальнейшего обращения к предоставляемым структурам данных.
Далее управление передается функции dmi_present:
static int __init dmi_present(const char __iomem *p)
{
/* Считываем данные из области ввода-вывода */
memcpy_fromio(buf, p, 15);
/* Проверяем наличие специальной сигнатуры блока DMI */
if ((memcmp(buf, &quot;_DMI_&quot;, 5) == 0) &amp;&amp; dmi_checksum(buf))
{
dmi_num = (buf[13] &lt;&lt; 8) | buf[12];
dmi_len = (buf[7] &lt;&lt; 8) | buf[6];
dmi_base = (buf[11] &lt;&lt; 24) | (buf[10] &lt;&lt; 16) |
(buf[9] &lt;&lt; 8) | buf[8];
/* Информируем пользователя о том, что запись DMI была обнаружена */
if (buf[14] != 0)
printk(KERN_INFO &quot;DMI %d.%d present.\n&quot;,
buf[14] &gt;&gt; 4, buf[14] &amp; 0xF);
else
printk(KERN_INFO &quot;DMI present.\n&quot;);
/* Анализ записей DMI, формирование описанного списка устройств */
if (dmi_walk_early(dmi_decode) == 0)
return 0;
}
return 1;
}
Функция проводит анализ стандартного заголовка DMI. Если он
присутствует - происходит обнаружение адреса, по которому могут быть
обнаружены интересующие нас записи, а также длины информационных
структур DMI. Данная информация сохраняется в глобальных переменных
модуля. Если все предварительные операции прошли корректно -
управление передается функции разбора DMI-данных dmi_decode(), путем
передачи указателя на нее механизму циклического перебора DMI-записей
(dmi_walk_early):
static void __init dmi_decode(const struct dmi_header *dm)
{
/* Осуществляем обработку каждой записи DMI в зависимости от ее типа */
switch(dm-&gt;type)
{
case 0: /* BIOS Information */
dmi_save_ident(dm, DMI_BIOS_VENDOR, 4);
dmi_save_ident(dm, DMI_BIOS_VERSION, 5);
dmi_save_ident(dm, DMI_BIOS_DATE, 8);
break;
case 1: /* System Information */
dmi_save_ident(dm, DMI_SYS_VENDOR, 4);
dmi_save_ident(dm, DMI_PRODUCT_NAME, 5);
dmi_save_ident(dm, DMI_PRODUCT_VERSION, 6);
dmi_save_ident(dm, DMI_PRODUCT_SERIAL, 7);
dmi_save_uuid(dm, DMI_PRODUCT_UUID, 8);
break;
/* ... */
/* Если запись информирует о наличии специализированного устройства -
добавляем его в общесистемный список */
case 11: /* OEM Strings */
dmi_save_oem_strings_devices(dm);
break;
}
}
Теперь обратимся к реализации самой функции формирования списка,
отметив тот факт, что она вызывается множество раз - для добавления
информации о каждом описанном в DMI-данных устройстве:
/* Универсальная структура, добавление которой в список происходит
при обнаружении пустой строки в OEM-описании */
static struct dmi_device empty_oem_string_dev =
{
.name = dmi_empty_string,
};
static void __init dmi_save_oem_strings_devices(const struct dmi_header *dm)
{
int i, count = *(u8 *)(dm + 1);
struct dmi_device *dev;
for (i = 1; i &lt;= count; i++)
{
char *devname = dmi_string(dm, i);
if (!strcmp(devname, dmi_empty_string))
{
/* Если DMI - запись пуста - добавляем в список описатель пустого устройства */
list_add(&amp;empty_oem_string_dev.list, &amp;dmi_devices);
continue;
}
dev = dmi_alloc(sizeof(*dev));
/* Проверки корректности выделения памяти */
dev-&gt;type = DMI_DEV_TYPE_OEM_STRING;
dev-&gt;name = devname;
dev-&gt;device_data = NULL;
/* Если запись не пуста добавляем вновь сформированный описатель */
list_add(&amp;dev-&gt;list, &amp;dmi_devices);
}
}
В ходе выполнения данной процедуры, если пустая строка описания была
встречена в нескольких DMI записях - добавляется одна и та же
универсальная запись `empty_oem_string_dev`, которая описанным выше
способ разрушает список множественным добавлением.
Корректная версия драйвера не должна осуществлять дублирующую вставку
в общесистемный список следующим образом:
static void __init dmi_save_oem_strings_devices(const struct dmi_header *dm)
{
int i, count = *(u8 *)(dm + 1);
struct dmi_device *dev;
for (i = 1; i &lt;= count; i++)
{
char *devname = dmi_string(dm, i);
if (!strcmp(devname, dmi_empty_string))
{
/* Если DMI - запись пуста - не добавляем ничего, т.к. полезной информации
запись все равно не несет */
continue;
}
dev = dmi_alloc(sizeof(*dev));
/* Проверки корректности выделения памяти */
dev-&gt;type = DMI_DEV_TYPE_OEM_STRING;
dev-&gt;name = devname;
dev-&gt;device_data = NULL;
/* Если запись не пуста добавляем вновь сформированный описатель */
list_add(&amp;dev-&gt;list, &amp;dmi_devices);
}
}
Методом проверки может служить атрибут `добавлен в список` для каждой
`внутренней структуры list_head` (т.к. глобальные структуры могут
содержать несколько вхождений типа list_head для присутствия
одновременно в нескольких списках).
Если он установлен (т.е. ранее был достигнут участок кода, который
добавлял этот элемент в какой-либо общесистемный списко и более поздней
операции извлечения из списка не проводилось) - повторное добавление
должно приводить к сообщению об ошибке.

Подменить тип структуры struct list_head (include/linux/list.h)
добавив поле int inserted (инициализируется в 0)
void list_add(struct list_head *new, struct list_head *head)
{
  assert( new-&gt;inserted==0 );
  new-&gt;inserted=1;
  //продолжение
}
аналогично list_add_tail
list_del(struct list_head *entry)
{
  assert( entry-&gt;inserted==1 );
  entry-&gt;inserted=0;
  //продолжение
}
аналогично list_replace,  list_replace_init, list_del_init, list_move, list_move_tail, list_cut_position</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Оповещение о наличии неиспользуемых областей выделенной динамической памяти</Имя>
<ID>0061</ID>
<НАЗНАЧЕНИЕ>Средства компиляции позволяют выявлять случаи неиспользуемых стековых
переменных или переданных функции параметров. При этом
осуществляется корректный вывод соответствующего информационного
сообщения.
Однако в стороне остается множество аналогичных ситуаций, когда мы
имеем дело с областями динамической памяти (выделенными из “системной
кучи” с помощью kmalloc(), vmalloc() и т.д.).
Для примера рассмотрим следующую функцию подсистемы ATA ядра:
static int sata_fsl_probe(struct of_device *ofdev,
const struct of_device_id *match)
{
/* ... */
/* Указатель на неиспользуемую в дальнейшем область памяти */
struct resource *r;
int irq;
struct ata_host *host;
struct ata_port_info pi = sata_fsl_port_info[0];
const struct ata_port_info *ppi[] = { &amp;pi, NULL };
dev_printk(KERN_INFO, &amp;ofdev-&gt;dev,
&quot;Sata FSL Platform/CSB Driver init\n&quot;);
/* Корректное выделение памяти, которая в дальнейшем не используется */
r = kmalloc(sizeof(struct resource), GFP_KERNEL);
/* К области памяти, адресуемой `r` нет прямых или косвенных обращений */
/* Если память не освобождена корректно – см. соответствующее правило */
/* В случае применения требуемые методов освобождения памяти случай следует
трактовать как нарушение текущего правила */
}
Реализовать такого рода проверку средствами компиляции невозможно –
формально, переменной `r` присвоено некоторое значение (полученное в
качестве результата работы функции) – она является используемой в коде.

ССЫЛКА НА ОРИГИНАЛ LKML - СООБЩЕНИЯ:
drivers/ata/sata_fsl.c:
http://kerneltrap.org/mailarchive/git-commits-head/2008/4/10/1388394</НАЗНАЧЕНИЕ>
<ПРИМЕР>ПРИМЕР РЕАЛИЗОВАННОЙ РЕКОМЕНДАЦИИ:
2.6.25 -&gt; drivers/ata/sata_fsl.c</ПРИМЕР>
<ВЕРИФИКАЦИЯ>ПРИМЕР И МЕТОДИКА ОБНАРУЖЕНИЯ:
Предлагается ассоциировать с результатом операций выделения
динамической памяти некий атрибут, характеризующий возможное
обращение к данной области.
Если на момент освобождения этого региона памяти атрибут указывает на
то, что обращения к нему не производились – следует отображать
соответствующее информационное сообщение типа `warning`
Важно отметить, что в случае передачи значения данной переменной
(указателя) в сторонние подсистемы ОС осуществлять выдачу сообщения
необходимо лишь при наличии каких-либо гарантий отсутствия попыток
доступа к адресуемой памяти из означенных выше сторонних подсистем.
Это возможно лишь в случае проведения полного анализа исходного кода
всех взаимосвязанных модулей.

Похожее правило ID 0057</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ.</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Запрет применения средств управления динамической памятью к объектам, размещенным в стеке</Имя>
<ID>0062</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.25.y.git;a=commit;h=2875fb65f8e40401c4b781ebc5002df10485f635</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/mtd/devices/block2mtd.c:

@@ 382

char buf[80 + 12];

/* name указывает на определенный элемент массива buf */

@@ 408

if (token[1]) {
   ret = parse_num(&amp;erase_size, token[1]);
   if (ret) {
      /* некорректная попытка освобождения области &quot;стековой&quot; памяти
      kfree(name);
      parse_err(&quot;illegal erase size&quot;);
   }
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требует отслеживания присваивания переменных.
То же самое что ID0056?</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ. Safety</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Заведомо ошибочное использование конструкций вида sizeof(sizeof(OBJ))</Имя>
<ID>0063</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=3f6602ad56dc538a846367bd6a05ac7ac4d3e641</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/net/r6040.c:

@@ 273

dma_addr_t mapping = desc_dma;

while (size-- &gt; 0) {
mapping += sizeof(sizeof(*desc)); /* ошибка */
mapping += sizeof(*desc);         /* корректный вариант */
desc-&gt;ndesc = cpu_to_le32(mapping);
desc-&gt;vndescp = desc + 1;
desc++;
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>grep sizeof ( sizeof (</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС. Синтаксическое</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Некорректное задание размера буфера-приемника процедур типа strcat</Имя>
<ID>0064</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=af2afd247f0fae25d66f210fb800fe6a2958366e

В случае необходимости явного задания размера буфера-приемника процедуры типа strcat необходимо применять strlcat() вместо strncat() Процедура strncat() в качестве одного из аргументов принимает количество символов, которые допустимо дописать в буфер-приемник, в отличие от strlcat(), принимающей итоговый максимальный размер буфера.</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/video/aty/aty128fb.c:

@@ 1885

if (ent-&gt;driver_data &lt; ARRAY_SIZE(r128_family))
   /* некорректный вызов, потерян смысл последнего аргумента */
   strncat(video_card, r128_family[ent-&gt;driver_data], sizeof(video_card));
   /* правильно */
   strlcat(video_card, r128_family[ent-&gt;driver_data], sizeof(video_card));

printk(KERN_INFO &quot;aty128fb: %s [chip rev 0x%x] &quot;, video_card, chip_rev);</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Сделать реализацию strncat, в которой сравнивать переданный размер с размером доступным по указателю. Сложность: как определить размер доступный по указателю? Одним из решений было бы отслеживание параметров в точках вызова.

Записано подменой функции strncat на env_strncat с дополнительным параметром - размером переданного буфера.
char *env_strncat(char *dest, const char *src, size_t count, size_t size_of_dest)
{
  assert(  src+count &lt;= dest + size_of_dest);
  //модельный код
}</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ. Safety</ВЕРТИП>
<СОСТОЯНИЕ>WRITTEN</СОСТОЯНИЕ>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Запрет вызова dma_alloc_pages для устройства, не предоставляющего специализированной маски выделения памяти для DMA-операций</Имя>
<ID>0065</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=bb8ada95a7c11adf3dad4e8d5c55ef1650560592

Если устройство (представлено структурой struct device) не предоставляет специализированной маски выделения памяти для DMA-операций (поле dma_mask == NULL) - не допустимо применение к нему функции выделения DMA-совместимой памяти (dma_alloc_pages())</НАЗНАЧЕНИЕ>
<ПРИМЕР>arch/x86/kernel/pci-dma_32.c:

@@ 72

void *dma_alloc_coherent(struct device *dev, size_t size,
                         dma_addr_t *dma_handle, gfp_t gfp) {

/* необходимо введение дополнительной проверки перед вызовом dma_alloc_pages()*/
if (dev-&gt;dma_mask == NULL)
   return NULL;

gfp |= __GFP_NORETRY;
page = dma_alloc_pages(dev, gfp, order);

...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Сравнивать переданное поле структуры dma_mask на NULL.
dma_alloc_pages(dev, gfp, order)
{
assert(dev-&gt;dma_mask!=NULL);
//модельный код
...
}
Данная версия BLAST это правило скорее всего не потянет.

dma_alloc_pages не найдена в заголовочных файлах ядра. Это означает что dma_alloc_pages не может вызываться напрямую из драйвера. Вместо этого в ./asm/dma-mapping.h определена функция dma_alloc_coherent. Можно ли наложить какие то требования на нее?</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ. Safety</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Проверка наличия форматного символа `%` в символических именах устройств</Имя>
<ID>0066</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=b37d428b24ad38034f56b614de05686ba151b614

Часто символические имена сетевых устройств, регистрируемых функцией register_netdevice(), приходят из пространства пользователя.
Необходимо осуществлять проверку наличия форматного символа `%` в полученной строке. При положительном результате проверки следует предварительно передать данное имя функции dev_alloc_name(), осуществляющей подстановку соответствующего номера устройства в качестве параметра.</НАЗНАЧЕНИЕ>
<ПРИМЕР>net/ipv4/ip_gre.c:

@@ 266

if (!dev)
   return NULL;

/* требуемая правилом проверка */
if (strchr(name, '%')) {
   if (dev_alloc_name(dev, name) &lt; 0)
   goto failed_free;
}

   dev-&gt;init = ipgre_tunnel_init;
   nt = netdev_priv(dev);
   nt-&gt;parms = *parms;

   if (register_netdevice(dev) &lt; 0)
      goto failed_free;</ПРИМЕР>
<ВЕРИФИКАЦИЯ>register_netdevice(dev)
{
assert (!strchr(dev-&gt;name, '%')));
//модельный код
}

Как определить, что переменная является символическим именем устройства и пришла из пространства пользователя?</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Проверка корректности монтирования корневой файловой системы</Имя>
<ID>0067</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=0d63e4f9ea61df1d727bd52a174aba732e6e1853

Многие драйверы осуществляют проверку корректности монтирования корневой файловой системы. Однако такого рода активность становится бессмысленной ввиду блокирования загрузки при невозможности монтирования rootfs.</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/pnp/pnpbios/core.c:

@@ 106

int i = 0, value;

/* данную проверку можно исключить */
if (!current-&gt;fs-&gt;root)
   return -EAGAIN;

if (!(envp = kcalloc(20, sizeof(char *), GFP_KERNEL)))
   return -ENOMEM;

Проблема также наблюдается:
sound/core/seq/seq_clientmgr.c
sound/core/seq/seq_device.c
sound/core/sound.c
sound/core/timer.c
sound/ppc/daca.c
sound/ppc/tumbler.c</ПРИМЕР>
<ВЕРТИП>РС. Синтаксическое</ВЕРТИП>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Избежание NULL-noise ситуаций</Имя>
<ID>0069</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=blobdiff;f=drivers/net/3c515.c;h=6ab84b661d70b34549d954ff9f173e07be06bd41;hp=684bab7810156998f3fd366b27ac1b645d5169e7;hb=79ea13ce07c951bb4d95471e7300baa0f1be9e78;hpb=3e18826c73735eee5fca92584137824d9a387008

Избежание NULL-noise ситуаций, т.е. попыток проверки результата операций выделения регионов памяти (возвращающих указатель) на равенство нулю, вместо NULL.</НАЗНАЧЕНИЕ>
<ВЕРИФИКАЦИЯ>drivers/net/3c515.c:

@@ 1363

/* неверная проверка */
if (pkt_len &lt; rx_copybreak  &amp;&amp; (skb = dev_alloc_skb(pkt_len + 4)) != 0)
/* правильно */
if (pkt_len &lt; rx_copybreak  &amp;&amp; (skb = dev_alloc_skb(pkt_len + 4)) != NULL) {
   skb_reserve(skb, 2);
...
}

Когда NULL!=0?</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС. Синтаксическое</ВЕРТИП>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Использование kobject_unregister() вместо kobject_put()</Имя>
<ID>0070</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=c10997f6575f476ff38442fa18fd4a0d80345f9d

В связи со введением новой системы очистки, нет необходимости в использовании процедуры kobject_unregister(). Следует применять kobject_put().</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/base/bus.c:

@@ 708
pr_debug(&quot;bus: '%s': remove driver %s\n&quot;, drv-&gt;bus-&gt;name, drv-&gt;name); driver_detach(drv); module_remove_driver(drv);
/* используемый вариант */
kobject_unregister(&amp;drv-&gt;p-&gt;kobj);
/* рекомендуемое поведение */
kobject_put(&amp;drv-&gt;p-&gt;kobj);

Проблема также наблюдается:
drivers/base/sys.c
drivers/block/pktcdvd.c
drivers/cpufreq/cpufreq.c
drivers/cpuidle/sysfs.c
drivers/edac/edac_device_sysfs.c
drivers/edac/edac_mc_sysfs.c
drivers/edac/edac_pci_sysfs.c
drivers/firmware/edd.c
drivers/firmware/efivars.c
drivers/infiniband/core/sysfs.c
drivers/md/md.c
drivers/net/ibmveth.c
drivers/parisc/pdc_stable.c
drivers/pci/hotplug/pci_hotplug_core.c
drivers/pci/hotplug/rpadlpar_sysfs.c
drivers/uio/uio.c</ПРИМЕР>
<ВЕРТИП>РС. Синтаксическое</ВЕРТИП>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Переход к новому интерфейсу инициализации/добавления kobject</Имя>
<ID>0071</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=649316b25b148e57c8ef71748fc69fa6db276ad1

Переход к новому интерфейсу инициализации/добавления kobject

Вместо группы действий:
kobject_set_name();
object.parent = ...;
kobject_add();

Применяется единая функция kobject_add_ng() (ng = new generation)</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/md/md.c:

@@ 1387

/* ранее используемый механизм */

if (kobject_set_name(&amp;rdev-&gt;kobj, &quot;dev-%s&quot;, b) &lt; 0)
   return -ENOMEM;
while ( (s=strchr(rdev-&gt;kobj.k_name, '/')) != NULL)

rdev-&gt;mddev = mddev;
printk(KERN_INFO &quot;md: bind&lt;%s&gt;\n&quot;, b);

rdev-&gt;kobj.parent = &amp;mddev-&gt;kobj;
if ((err = kobject_add(&amp;rdev-&gt;kobj)))
   goto fail;

/* ng */

while ( (s=strchr(b, '/')) != NULL)
   *s = '!';
if ((err = kobject_add_ng(&amp;rdev-&gt;kobj, &amp;mddev-&gt;kobj, &quot;dev-%s&quot;, b)))
   goto fail;</ПРИМЕР>
<ВЕРТИП>РС. Синтаксическое</ВЕРТИП>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>RCU-API Checking</Имя>
<ID>0072</ID>
<НАЗНАЧЕНИЕ>The RCU algorithm was implemented for the Linux kernel to gain speed-ups for
shared complex data types like lists. The main idea is to avoid synchronization
operations whenever possible. Disregarding the internal implementations of the
algorithm, we extracted a partial black box specification from the kernel documentation:
If a list element is deleted from an RCU list by a call to list del rcu,
this element may not be deallocated prior to a call to synchronize rcu or
call rcu. Here we must annotate calls to the above functions as well as calls to
kfree() in order to track the memory-state of the list.</НАЗНАЧЕНИЕ>
<ВЕРИФИКАЦИЯ>/**
 * list_del_rcu - deletes entry from list without re-initialization
 * @entry: the element to delete from the list.
 *
 * Note: list_empty on entry does not return true after this,
 * the entry is in an undefined state. It is useful for RCU based
 * lockfree traversal.
 *
 * In particular, it means that we can not poison the forward
 * pointers that may still be used for walking the list.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_del_rcu()
 * or list_add_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 *
 * Note that the caller is not permitted to immediately free
 * the newly deleted entry.  Instead, either synchronize_rcu()
 * or call_rcu() must be used to defer freeing until an RCU
 * grace period has elapsed.
 */

state{
	int synchronized = 1; // only is 0 between a call to list_del_rcu and a call to synchronize_rcu/call_rcu
	void *which_entry = NULL;
}

list_add_rcu.entry{
	if($1 &amp;&amp; !which_entry){
		if(*){
			which_entry = $1;
			synchronized = 1;
		}
	}
}

list_add_tail_rcu.entry{
	if($1 &amp;&amp; !which_entry){
		if(*){
			which_entry = $1;
			synchronized = 1;
		}
	}
}

list_del_rcu.entry{
	if($1 &amp;&amp; (which_entry == $1)){
		synchronized = 0;
	}
}

synchronize_rcu.entry{
	synchronized = 1;
}

call_rcu.entry{
	synchronized = 1;
}

kfree.entry{
	if($1 &amp;&amp; ($1 == which_entry)){
		if(!synchronized){
			abort &quot;list entry kfreed without list synchronization!&quot;;
		}
	}
}</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Взято из Avinux
http://www-sr.informatik.uni-tuebingen.de/~post/avinux/index.html</ПРИМЕЧАНИЯ>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Попытка повторного вызова free irq</Имя>
<ID>0073</ID>
<НАЗНАЧЕНИЕ>free_irq()</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ВЕРТИП>ДВ</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Необязательный вызов synchronize_irq() перед free_irq()</Имя>
<ID>0074</ID>
<НАЗНАЧЕНИЕ>free_irq() calls synchronize_irq() for you, so there is no need for
    drivers to manually do the same thing (again).  Thus, calls where
    sync-irq immediately precedes free-irq can be simplified.</НАЗНАЧЕНИЕ>
<ПРИМЕР>http://kerneltrap.org/mailarchive/git-commits-head/2008/4/24/1584714</ПРИМЕР>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_WARNING item="y">
<Имя>Обязательное использование gpio_{request,free}()</Имя>
<ID>0075</ID>
<НАЗНАЧЕНИЕ>We want to phase out the GPIO &quot;autorequest&quot; mechanism in gpiolib and
    require all callers to use gpio_request().

     - Update feature-removal-schedule
     - Update the documentation now
     - Convert the relevant pr_warning() in gpiolib to a WARN()
       so folk using this mechanism get a noisy stack dump

    Some drivers and board init code will probably need to change.
    Implementations not using gpiolib will still be fine; they are already
    required to implement gpio_{request,free}() stubs</НАЗНАЧЕНИЕ>
<ПРИМЕР>http://kerneltrap.org/mailarchive/git-commits-head/2009/4/3/5372974</ПРИМЕР>
</ПРАВИЛО_WARNING>
<ПРАВИЛО_ERROR item="y">
<Имя>Захват mutex перед вызовом некоторых функций</Имя>
<ID>0076</ID>
<НАЗНАЧЕНИЕ>В некоторых функциях имеется предусловие вызова - захват некоторой блокировки. Функцию нельзя вызывать без захвата этой блокировки.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>http://bugzilla.kernel.org/show_bug.cgi?id=13227

drm_gem_object_free() (drivers/gpu/drm/drm_gem.c) requires dev-&gt;struct_mutex to
be locked before a call.

&gt; drm_gem_object_free(struct kref *kref)
&gt; {
&gt;     struct drm_gem_object *obj = (struct drm_gem_object *) kref;
&gt;     struct drm_device *dev = obj-&gt;dev;
&gt;
&gt;     BUG_ON(!mutex_is_locked(&amp;dev-&gt;struct_mutex));
&gt; ...

drm_gem_object_free is mostly called through
drm_gem_object_unreference(include/drm/drmP.h).

&gt; static inline void
&gt; drm_gem_object_unreference(struct drm_gem_object *obj)
&gt; {
&gt;         if (obj == NULL)
&gt;                 return;
&gt;
&gt;         kref_put(&amp;obj-&gt;refcount, drm_gem_object_free);
&gt; }

The potential issues may come from the following sources.

1. i915_gem_set_tiling (drivers/gpu/drm/i915/i915_gem_tiling.c)

&gt; int
&gt; i915_gem_set_tiling(struct drm_device *dev, void *data,
&gt;            struct drm_file *file_priv)
&gt; {
&gt;         struct drm_i915_gem_set_tiling *args = data;
&gt;         drm_i915_private_t *dev_priv = dev-&gt;dev_private;
&gt;         struct drm_gem_object *obj;
&gt;         struct drm_i915_gem_object *obj_priv;
&gt;
&gt;         obj = drm_gem_object_lookup(dev, file_priv, args-&gt;handle);
&gt;         if (obj == NULL)
&gt;             return -EINVAL;
&gt;         obj_priv = obj-&gt;driver_private;
&gt;
&gt;         if (!i915_tiling_ok(dev, args-&gt;stride, obj-&gt;size, args-&gt;tiling_mode)) {
&gt;               drm_gem_object_unreference(obj);  &lt;----- ISSUE #1: unreference before unlock
&gt;               return -EINVAL;
&gt;         }
&gt;
&gt;         mutex_lock(&amp;dev-&gt;struct_mutex);
&gt;         ...
line 317:
&gt;               ret = i915_gem_object_unbind(obj);
&gt;               if (ret != 0) {
&gt;                       WARN(ret != -ERESTARTSYS,
&gt;                            &quot;failed to unbind object for tiling switch&quot;);
&gt;                       args-&gt;tiling_mode = obj_priv-&gt;tiling_mode;
&gt;                       mutex_unlock(&amp;dev-&gt;struct_mutex);
&gt;                       drm_gem_object_unreference(obj);  &lt;----- ISSUE #2: unreference after unlock
&gt;
&gt;                       return ret;

2. i915_gem_pread_ioctl and i915_gem_pwrite_ioctl
(drivers/gpu/drm/i915/i915_gem.c)

&gt; int
&gt; i915_gem_pread_ioctl(struct drm_device *dev, void *data,
&gt;                      struct drm_file *file_priv)
&gt; {
&gt;       struct drm_i915_gem_pread *args = data;
&gt;       struct drm_gem_object *obj;
&gt;       struct drm_i915_gem_object *obj_priv;
&gt;       int ret;
&gt;
&gt;       obj = drm_gem_object_lookup(dev, file_priv, args-&gt;handle);
&gt;       if (obj == NULL)
&gt;               return -EBADF;
&gt;       obj_priv = obj-&gt;driver_private;
&gt;
&gt;       /* Bounds check source.
&gt;        *
&gt;        * XXX: This could use review for overflow issues...
&gt;        */
&gt;       if (args-&gt;offset &gt; obj-&gt;size || args-&gt;size &gt; obj-&gt;size ||
&gt;           args-&gt;offset + args-&gt;size &gt; obj-&gt;size) {
&gt;               drm_gem_object_unreference(obj);  &lt;----- ISSUE #3: unreference without lock
&gt;               return -EINVAL;
&gt;       }
&gt;
&gt;       if (i915_gem_object_needs_bit17_swizzle(obj)) {
&gt;               ret = i915_gem_shmem_pread_slow(dev, obj, args, file_priv);
&gt;       } else {
&gt;               ret = i915_gem_shmem_pread_fast(dev, obj, args, file_priv);
&gt;               if (ret != 0)
&gt;                       ret = i915_gem_shmem_pread_slow(dev, obj, args,
&gt;                                                       file_priv);
&gt;       }
&gt;
&gt;       drm_gem_object_unreference(obj);  &lt;----- ISSUE #4: unreference without lock
&gt;
&gt;       return ret;
&gt; }

The same is for i915_gem_pwrite_ioctl().</ПРИМЕР>
<ВЕРТИП>ДВ</ВЕРТИП>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Disable IO during memory allocation while holding usb divice lock</Имя>
<ID>0077</ID>
<НАЗНАЧЕНИЕ>Memory allocations with GFP_KERNEL can cause IO to a storage
device which can fail resulting in a need to reset the device.
Therefore GFP_KERNEL cannot be safely used between usb_lock_device()
and usb_unlock_device(). Replace by GFP_NOIO.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.32.y.git;a=commitdiff;h=186c74d336e2c1377df9e5dc88f7966b2dd6acf7</ПРИМЕР>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Dereference after kfree</Имя>
<ID>0078</ID>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>dereference after kfree() (kzfree, etc)
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.32.y.git;a=commitdiff;h=44a529c6b32a9254cacc0d0c6423967883d8ebcd
http://git.kernel.org/?p=linux/kernel/git/stable/linux-2.6.32.y.git;a=commitdiff;h=fa00e106eb6f082654d822a0946c0c86297ede2c</ПРИМЕР>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<ID>0079</ID>
<ПРИМЕР>Advance the correct pointer when inserting the linebreak for the HBA
trace. It was missing in the output since the pointer to the output
buffer was never advanced, and the linebreak character was overwritten
later.
drivers/s390/scsi/zfcp_dbf.c
-               p += sprintf(*p, &quot;\n&quot;);
+               *p += sprintf(*p, &quot;\n&quot;);</ПРИМЕР>
</ПРАВИЛО_ERROR>
</ГРУППА>
<ГРУППА item="y">
<Имя>CHAR DEVICES</Имя>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>[CDEV] Использование более комплексного метода управления интерфейсами драйвера символьного устройства к файловой системе</Имя>
<ID>0017</ID>
<НАЗНАЧЕНИЕ>Механизм CDEV, хотя и является на первый взгляд более сложным, позволяет избежать реализации многих дополнительных проверок (особенно связанных с контролем диапазона младших версий зарегистрированного устройства).
Также подход CDEV обеспечивает взаимодействие с sysfs, которая в будущем имеет все шансы полностью вытеснить /proc, что делает данных подход более актуальным, чем использование методов register_chrdev()/unregister_chrdev()</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>struct cdev* mydev = cdev_alloc();
cdev_init(mydev,/*struct file_operations*/my_file_ops);
mydev-&gt;owner=THIS_MODULE;
kobject_set_name(&amp;mydev-&gt;kobj,&quot;mydev_%d&quot;,/*идентификатор*/devnum);
if(!cdev_add(mydev,MAJOR_VERSION_START_ID,COUNT))
{
//Обработка ошибки
kobject_put(&amp;mydev-&gt;kobj);
//Обязательное использование для уменьшения счетчика использования объекта
}
else
{
//Период нормального функционирования интерфейса
...
//Освобождение
cdev_del(mydev);
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Выдавать рекомендацию при обнаружении вызовов register_chrdev()/unregister_chrdev().
Следует подчеркнуть, что в ряде случаев (особенно при реализации простых механизмов регистрации устройств в ФС) использование CDEV необаснованно, поэтому пункт рассматривается исключительно как &quot;Рекомендация&quot;</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>[CDEV] Требование использования функции kobject_put() вместо cdev_del() (для освобождения объекта) при ошибке регистрации устройства (ненулевом возврате из cdev_add())</Имя>
<ID>0018</ID>
<НАЗНАЧЕНИЕ>Исключить возможное аварийное завершение работы при попытке применения функции cdev_del() к объекту &quot;обработчик символьного устройства&quot; cdev, который не был успешно зарегистрирован в системе функцией cdev_add()</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>struct cdev* mydev = cdev_alloc();
//инициализация
if(!cdev_add(mydev,MAJOR_VERSION_START_ID,COUNT))
{
//Обработка ошибки
kobject_put(&amp;mydev-&gt;kobj);
//Обязательное использование для уменьшения счетчика использования объекта
}
else
{
//Период нормального функционирования интерфейса
...
//Освобождение
cdev_del(mydev);
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требует проверять листинг на предмет обработки кода возврата функции cdev_add().
Ветвь-обработчик ошибочного возврата не должна содержать вызова cdev_del(), так как это приведет к аварийному завершению работы.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Если cdev_add вернул ошибочный код возврата, то cdev_del не может быть вызван, а должен быть вызван kobject_put.
Еще одно правило: после cdev_add должно быть cdev_del

Примеры драйверов для верификации:
$KERNEL_SOURCE/drivers/s390/char/vmlogrdr.c

Пример кода драйвера:

	rc = cdev_add(vmlogrdr_cdev, vmlogrdr_cdev-&gt;dev, MAXMINOR);
	if (!rc)
		return 0;

	// cleanup: cdev is not fully registered, no cdev_del here!
	kobject_put(&amp;vmlogrdr_cdev-&gt;kobj);
	vmlogrdr_cdev=NULL;
	return rc;

В ядре 2.6.9 драйвера $KERNEL_SOURCE/drivers/s390/char/vmlogrdr.c нет!</ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ>WRITTEN, EXAMPLE_ATTACHED</СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
</ГРУППА>
<ГРУППА item="y">
<Имя>BLOCK DEVICES</Имя>
<ПРАВИЛО_ERROR item="y">
<Имя>Требование освобождения ресурсов gendisk-интерфейса</Имя>
<ID>0026</ID>
<НАЗНАЧЕНИЕ>Обеспечить отсутствие утечек памяти и возможных нарушений работы системы, связанных с обращением к отсутствующим элементам интерфейса управления блочными устройствами.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>struct gendisk* gd;
int init_module()
{
...
gd=alloc_disk(32 /*количество minor-устройств*/);
//дальнейшая инициализация интерфейса gendisk
gd-&gt;first_minor=0;
...
}

void module_exit()
{
...
//код завершений работы и освобождения ресурсов gendisk-интерфейса
del_gendisk(gd); //отключение интерфейса объекта
put_disk(gd); //освобождение памяти
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>При использовании в коде модуля ядра функций интерфейса работы с gendisk - функционалом операционной системы (alloc_disk(), add_disk()) необходимо явно требовать использования соответствующих механизмов очистки (del_gendisk(), put_disk())</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>После вызова alloc_disk или add_disk должен быть вызов del_gendisk, а затем put_disk.
Обязательно ли последовательность: del_gendisk, а затем put_disk.

YEP! del_gendisk only remove our object from sysfs, but if we free object BEFORE removing from fs, smb can try to access it!!!

Перед добавлением диска add_disk обязательно нужно выделять под него память alloc_disk.</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Корректное использование механизма request_queue очередей обращений к блочным устройствам</Имя>
<ID>0027</ID>
<НАЗНАЧЕНИЕ>Обеспечить требуемую операцию деактивации и освобождения очереди ожидания</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>struct gendisk* gd;
int init_module()
{
...
gd=alloc_disk(32 /*количество minor-устройств*/);
//дальнейшая инициализация интерфейса gendisk
gd-&gt;first_minor=0;
...
//инициализация интерфейса очередей ожидания
Queue = blk_init_queue(sbd_request /*обработчик запросов добавления новых заданий*/, &amp;lock_point /*spinlock_t* */);
if (Queue == NULL) goto out;
blk_queue_hardsect_size(Queue, HARD_SECT_SIZE);
//активация интерфейса очередей ожидания
gd-&gt;queue=Queue;
}

void module_exit()
{
...
//код завершений работы и освобождения ресурсов gendisk-интерфейса
del_gendisk(gd); //отключение интерфейса объекта
//ПРИМЕЧАНИЕ: производится также диакцивация интерфейса очереди gd-&gt;queue
put_disk(gd); //освобождение памяти

//код деактивации и освобождения ресурсов механизма очередей запросов
blk_cleanup_queue(Queue);
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>При проведении инициализации объекта очереди ожидания (struct request_queue) с помощью функции blk_init_queue(), требуется обеспечить корректное удаление данного объекта с использованием функции blk_cleanup_queue()</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>После вызова blk_init_queue должен быть вызов blk_cleanup_queue

Помимо вызова функции blk_init_queue может быть использован вызов blk_alloc_queue.</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ ВЫЗОВАМИ ФУНКЦИЙ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
</ГРУППА>
<ЛЕГЕНДА item="y">
<Имя>USB Subsystem</Имя>
<ПРАВИЛО_ERROR item="y">
<Имя>Требование предварительной инициализации блока запроса к подсистеме USB</Имя>
<ID>0040</ID>
<НАЗНАЧЕНИЕ>Исключить возможность наличия программных трасс, допускающих передачу подсистеме управления периферийным интерфейсом USB (в лице контроллеров OHCI/UHCI/EHCI системной
шины) неинициализированных или инициализированных с ошибками блоков запроса (URB - USB Request Block, представлен структурой struct urb).
В ряде случаев это может вызывать сбои в работе как конкретного периферийного устройста, обслуживаемого драйвером, так и всей подсистемы USB в целом.

*СПРАВКА:*
Работа с устройствами, подключенными к периферийному интерфейсу USB осуществляется блоками запроса транзакций (URB), которые проходят стандартный жизненный цикл, определяемый подсистемой USB ядра Linux:

* создание блока запроса (выделение памяти)
  usb_alloc_urb (...);

* инициализация блока в зависимости от типа транзакции (см. дальше)

* передача блока подсистеме Core USB для передачи
  usb_submit_urb (...);

* вызов callback-функции драйвера или ожидание `usb_complete_t` извещения
  об успешной отправке URB устройству (или фатальных ошибках его передачи)

* освобождение блока запроса
  usb_free_urb (...);</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>void some_data_send_func ()
{
    urb = usb_alloc_urb(0, GFP_KERNEL);
    if (!urb)
    {
                 retval = -ENOMEM;
                  goto error
        }
    /* ИНИЦИАЛИЗАЦИЯ*/
    usb_fill_bulk_urb(urb, dev-&gt;udev,
               usb_sndbulkpipe(dev-&gt;udev, dev-&gt;bulk_out_endpointAddr),
               buf, count, skel_write_bulk_callback, dev);

    /* ОТПРАВКА URB */
    retval = usb_submit_urb(urb, GFP_KERNEL);
    if (retval)
    {
    err(&quot;%s - failed submitting write urb, error %d&quot;, __FUNCTION__, retval);
        goto error;
    }
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Целью правила является исключение ситуаций, когда функции usb_submit_urb передается неверно инициализированный URB (хотя бы на одном из возможных маршрутов выполнения).
Необходимо требовать:

ЛИБО
Явный вызов одной из функций инициализации ЛИБО Ручное заполнение полей структуры (см. ID0041)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>Часто драйверы в целях экономии памяти используют малое число структур URB, осуществляя простую модификацию ее полей для инициализации разнообразных транзакций. Обычно в момент инициализации драйвера осуществляется выделение памяти под 1-5 такого рода структуры, а их освобождение происходит в момент деактивации драйвера.

USB-подсистема определяет 4 доступных типа транзакций и, соответственно, типа URB:
* Interrupt URB
* Bulk URB
* Control URB
* Isochronous URB

Каждый тип транзакции имеет свои предопределенные характеристики (например, зарезервированный объем траффика канала, требование обеспечения целостности данных или другие характеристики QoS)

Инициализация URB каждого типа различна и проводится рядом специализированных функций экспортируемых подсистемой USB (USB Core). Такого рода функция отсутствует только для Isochronous URB в силу малой востребованности данного типа транзакций периферийными устройствами.

* Interrupt URB
void usb_fill_int_urb (struct urb*, struct usb_device*, unsigned int pipe, \
                    void *buf, int buffer_length, ...)

* Bulk URB
void usb_fill_bulk_urb (struct urb*, struct usb_device*, unsigned int pipe, \
                    void *buf, int buffer_length, ...)

* Control URB
void usb_fill_control_urb (struct urb*, struct usb_device*, unsigned int pipe, \
                    void *buf, int buffer_length, ...)

* Isochronous URB

Стандартная функция инициализации отсутствует, требуется проводить ручное заполнение полей структуры (см. правило ID0041)</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Требование полной инициализации блока запроса к подсистеме USB</Имя>
<ID>0041</ID>
<НАЗНАЧЕНИЕ>Исключение ситуаций, когда разработчик драйвера не заполняет ряд полей структуры при ручной инициализации URB-блока Isochronous-транзакций. Корректный пример инициализации приведен ниже:

urb-&gt;dev = dev;
urb-&gt;context = uvd;
urb-&gt;pipe = usb_rcvisocpipe(dev, uvd-&gt;video_endp-1); interval = 1;
urb-&gt;transfer_flags = URB_ISO_ASAP; transfer_buffer = cam-&gt;sts_buf[i];
urb-&gt;complete = konicawc_isoc_irq; number_of_packets = FRAMES_PER_DESC;
urb-&gt;transfer_buffer_length = FRAMES_PER_DESC;
for (j=0; j &lt; FRAMES_PER_DESC; j++)
{
        urb-&gt;iso_frame_desc[j].offset = j;
        urb-&gt;iso_frame_desc[j].length = 1; }

ДЛЯ СПРАВКИ см. ID 0040

Из него можно выделить основные поля, требуемые к заполнению в обязательном порядке (трактовка - ERROR):
* dev
* context
* pipe
* interval
* transfer_flags
* transfer_buffer
* complete
* number_of_packets
* transfer_buffer_length
* iso_frame_desc</НАЗНАЧЕНИЕ>
<ВЕРИФИКАЦИЯ>Следует отслеживать факт заполнения полей, ассоциированных с каждым объектом URB, и требовать их ручного заполнения перед передачей Isochronous URB структуры в качестве параметра функции отправки блока запроса (sub_submit_urb)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Рекомендация по использованию стандартных функций инициализации URB</Имя>
<ID>0042</ID>
<НАЗНАЧЕНИЕ>Предлагать разработчику рассмотреть возможность использования стандартной функции инициализации URB-структуры вместо ручного заполения (для случаев Bulk, Interrupt и Control транзакци), что позволит избежать проблем с неполным заполнением требуем полей и упростит анализ кода.

ДЛЯ СПРАВКИ см. ID 0040</НАЗНАЧЕНИЕ>
<ВЕРИФИКАЦИЯ>Обнаруживать все не-Isochronous URB инициализируемые вручную и выдавать разработчику рекомендацию по использованию стандартной функции инициализации.

При ручном заполнение параметров структуры URB (struct URB), полем, косвенно характеризующим тип транзакции является struct urb.transfer_flags Если данное поле НЕ содержит среди прочих флагов, флаг URB_ISO_ASAP, то данная транзакция не является изохронной и, следовательно, ее блок URB может быть инициализирован одной из стандартных функций.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ
КАТЕГОРИЯ:I/O
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_ERROR item="y">
<Имя>Корректное освобождение информационных структур подсистемы USB</Имя>
<ID>0068</ID>
<НАЗНАЧЕНИЕ>2.6.24 -&gt; 2.6.25
http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=cb7cd42930d4421780e78323f62243350ea14789

Корректное освобождение информационных структур подсистемы USB.</НАЗНАЧЕНИЕ>
<ПРИМЕР>drivers/bluetooth/bpa10x.c:

@@ 378

urb = usb_alloc_urb(0, GFP_ATOMIC);
if (!urb)
   return -ENOMEM;
...
default:
   /* обязательное освобождение выделенного информационного блока */
   usb_free_urb(urb);</ПРИМЕР>
<ВЕРТИП>ДВ. Safety</ВЕРТИП>
<СОСТОЯНИЕ>WRITTEN</СОСТОЯНИЕ>
</ПРАВИЛО_ERROR>
</ЛЕГЕНДА>
<ГРУППА item="y">
<Имя>KERNEL CODING STYLE</Имя>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Использование типов данных, присутствующих в расширенных стандартах языка C, поддерживаемых компилятором GCC 3.x-4.x (например, C99) вместо типов, специфичных для кода ядра Linux</Имя>
<ID>0006</ID>
<НАЗНАЧЕНИЕ>Обеспечение максимальной переносимости кода модуля  ядра
Обеспечение простоты понимания кода со стороны программистов, не обладающих знаниями в области стандартной типизации ядра Linux</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>Использование типа uint8_t (C99) вместо __u8 и u_int8_t</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Сопоставление верифицируемого кода модуля со списком идентификаторов типов ядра /path_to_kernel_src/include/linux/types.h
Выдача предупреждения при использовании специфичных для ядра типов данных</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<ХАРАКТЕРИСТИКА>КАТЕГОРИЯ:СИНТАКСИС</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование синтаксиса неполной инициализации структур в стиле C99 вместо GCC-стиля</Имя>
<ID>0005</ID>
<НАЗНАЧЕНИЕ>Обеспечение максимальной переносимости кода модуля  ядра
Обеспечение простоты понимания кода со стороны программистов, не обладающих знаниями в области специализированных расширений GCC</НАЗНАЧЕНИЕ>
<ТИП>WARNING1</ТИП>
<ПРИМЕР>static struct file_operations fop = {
	.open = &amp;dev_open,
	.release = &amp;dev_close,
	.read = &amp;dev_read,
	.write = &amp;dev_write,
	.ioctl = &amp;dev_ioctl
};</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Обнаружение всех инициализаций в стиле расширений GCC

struct file_operations fops = {
      read: device_read,
      write: device_write,
      open: device_open,
      release: device_release
};</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ПС</ВЕРТИП>
<ХАРАКТЕРИСТИКА>КАТЕГОРИЯ:СИНТАКСИС
ПЕРЕМЕННЫЕ:ИНИЦИАЛИЗАЦИЯ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_WARNING>
</ГРУППА>
<ГРУППА item="y">
<Имя>2.4 KERNEL</Имя>
<ПРАВИЛО_ERROR item="y">
<Имя>Использование переменной типа int для хранение флагов CPU при использовании функции блокировки spin_lock_irqsave(...)</Имя>
<ID>0014</ID>
<НАЗНАЧЕНИЕ>Исключить возможность аварийного завершения модуля при работе на CPU 64-битной архитектуры, использующей 64-битное значение флагов состояния.
Ядра серии 2.4 НЕ обеспечивают контроль за передачей в функции spin_lock_irqsave(...)/spin_unlock_irqrestore(...) исключительно переменных типа unsigned long в качетсве хранилища флагов.</НАЗНАЧЕНИЕ>
<ТИП>ERROR1</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
int flags;
...
spin_lock_irqsave(&amp;info-&gt;irq_spinlock,flags); //аварийное завершение модуля при работе на CPU x64
...
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Запрет передачи в качестве второго параметра в функции spin_lock_irqsave(...)/spin_unlock_irqrestore(...) переменных отличных по типу от unsigned long.

!ПРИМЕЧАНИЕ: Ядра серии 2.6.x осуществляют самостоятельный контроль на уровне первичного разбора при компиляции модуля.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС или ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>flags должен передаваться по указателю?

Nope, cause SLIS it's only a macro that looks like {flag = blabla}</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ПАРАМЕТРЫ-ПЕРЕМЕННЫЕ
КОНТЕКСТ:ЛЮБОЙ
КАТЕГОРИЯ:СИНХРОНИЗАЦИЯ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
<ПРАВИЛО_ERROR item="y">
<Имя>Модификация таблицы системных вызовов sys_call_table в целях расширения функциональности исполняющего ядра.</Имя>
<ID>0015</ID>
<НАЗНАЧЕНИЕ>Исключить возможное аварийное завершение работы системы, связанное с возможными &quot;гонками&quot; в процессе выгрузки модуля (осуществить требуемую SMP блокировку на этапе выгрузки модуля невозможно). В этом случае возможна передача управления по адресу системного вызова, который уже отсутствует (вместо стандартной реакции на нулевой указатель обработчика - вызов функции sys_ni_syscall(...)).</НАЗНАЧЕНИЕ>
<ТИП>ERROR2</ТИП>
<ПРИМЕР>int some_kernel_module_func()
{
sys_call_table[__NR_fcntl] = (long)&amp;newsys_fcntl;
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется запретить изменение массива указателей на обработчики системных вызовов, адресуемого указателем sys_call_table. Допускается исключительно получение значения данных указателей (т.е. вызов обработчика системного вызова).

!ПРИМЕЧАНИЕ: Ядра серии 2.6.x не осуществляют экспортирование указателя sys_call_table, поэтому динамическое изменение таблицы системных вызовов стало невозможным.</ВЕРИФИКАЦИЯ>
<ВЕРТИП>ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>требуется контроль обращений к массиву</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>СИСТЕМНЫЕ ПЕРЕМЕННЫЕ:ОБРАЩЕНИЕ
КАТЕГОРИЯ:АРХИТЕКТУРА</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
</ГРУППА>
<ГРУППА item="y">
<Имя>NOT x86 ARCH</Имя>
<ГРУППА item="y">
<Имя>x64</Имя>
</ГРУППА>
<ГРУППА item="y">
<Имя>Power</Имя>
</ГРУППА>
</ГРУППА>
<ГРУППА item="y">
<Имя>Unknown Verification</Имя>
<ПРАВИЛО_RECOMMENDATION item="y">
<Имя>Использование флага __GFP_COLD в функциях выделения памяти при обращении к области RAM, использованной ранее DMA-контроллером</Имя>
<ID>0019</ID>
<НАЗНАЧЕНИЕ>Экономия ресурсов системы, так как область памяти к которой осуществлял обращение DMA-контроллер находится в &quot;устаревшем&quot; состоянии в кеше CPU и в любом случае требуется прямое обращение к  RAM.</НАЗНАЧЕНИЕ>
<ТИП>RECOMMENDATION</ТИП>
<ПРИМЕР>struct page* pg = alloc_pages(... | __GFP_COLD,ORDER);</ПРИМЕР>
<ВЕРИФИКАЦИЯ>!Проблема: невозможно явно определить, использовалась ли область памяти ранее в операциях ввода-вывода.</ВЕРИФИКАЦИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ФЛАГИ УПРАВЛЕНИЯ
КОНТЕКСТ:ЛЮБОЙ
СОСТОЯНИЕ:УПРАВЛЯЕМОЕ КОНТЕКСТОМ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ НИЗКОГО УРОВНЯ
УПРАВЛЕНИЕ ПАМЯТЬЮ:ИНТЕРФЕЙСЫ ВЫСОКОГО УРОВНЯ
КАТЕГОРИЯ:УПРАВЛЕНИЕ ПАМЯТЬЮ</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_RECOMMENDATION>
</ГРУППА>
<ГРУППА item="y">
<Имя>SMP/NUMA</Имя>
<ПРАВИЛО_WARNING item="y">
<Имя>Использование функций доступа get_cpu_var()/put_cpu_var() к per-cpu к переменным, вместо работы с per_cpu()</Имя>
<ID>0020</ID>
<НАЗНАЧЕНИЕ>Ядра серии 2.6.x являются полностью преемптивными, поэтому возможно вытеснение кода, выполняющегося в режиме ядра. В связи с этим возможна ситуация &quot;гонки&quot; между двумя процессами на одном физическом CPU.
Функции get_cpu_var()/put_cpu_var() осуществляют требуемые спин-блокировки уровня одного CPU.</НАЗНАЧЕНИЕ>
<ТИП>WARNING2</ТИП>
<ПРИМЕР>Код /net/socket.c:

DEFINE_PER_CPU(long,sockets_in_use);
...
get_cpu_var(sockets_in_use)++;
//ВАЖНО: результат get_cpu_var() является lvalue</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Требуется выдавать предупреждение при использовании макроса per_cpu() так как ядра серии 2.6.x являются преемптивными.


!Примечание: возможно отключение преемптивного механизма уровня ядра при сборке ядра; это не должно влиять на специфику написания драйверов так как они, в основном, рассчитаны на использование с различными сборками ядра (как преемптивными, так и нет)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС</ВЕРТИП>
<СОСТОЯНИЕ>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:ЗАПРЕТ ВЫЗОВА
ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КАТЕГОРИЯ:АРХИТЕКТУРА
ОСОБЕННОСТИ:UMA/NUMA/COMA</СОСТОЯНИЕ>
</ПРАВИЛО_WARNING>
</ГРУППА>
<ГРУППА item="y">
<Имя>2.4.x -&gt; 2.6.x</Имя>
<ОПИСАНИЕ item="y"
line0="{*Имя*}"
line1="{*Текст*}">
<Имя type="Text" ref="y">WHAT IS IT?</Имя>
<Текст type="Text">Правила проверки драйвера (модуля ядра) ядра, переносимого с ядер версии 2.4 на современную серию 2.6
В будущем данный раздел может стать частью правил модулей ядра серии 2.6!</Текст>
</ОПИСАНИЕ>
<ПРАВИЛО_ERROR item="y">
<Имя>Модификация функции-обработчика прерываний, с целью введения возвращаемого значения типа irqreturn_t  (указатель на функцию-обработчик имеет тип irq_handler_t), а также специализированных возвращаемых значений для организации группы обработчиков одного прерывания.</Имя>
<ID>0025</ID>
<НАЗНАЧЕНИЕ>Исключить ошибки компиляции модуля ядра, переносимого с платформ версии 2.4.x.

Требуется рекомендовать к использованию специализированный макрос IRQ_RETVAL(x), что повысит читаемость кода, позволит избежать возможных ошибок реализации обработчика, а также обеспечит корректное возвращаемое значение  функции-обработчика для случая организация цепочки обработчиков (необходимо осуществлять возврат IRQ_HANDLED в случае отработки обработчика и IRQ_NONE в случае, если данное прерывание должно быть обработано другой функцией цепочки)</НАЗНАЧЕНИЕ>
<ТИП>ERROR2</ТИП>
<ПРИМЕР>//возврат irqreturn_t
irqreturn_t irq_handler(int irq,void* data)
{
int return_code;
...
if(((struct devdesc*)data)-&gt;id!=5) return_code=0;
else
return_code=1;
//использование макроса IRQ_RETVAL
IRQ_RETVAL(return_code);
}</ПРИМЕР>
<ВЕРИФИКАЦИЯ>Функция-обработчик передаваемая как аргумент вызову request_irq() должна иметь верный прототип (проверка осуществляется на этапе компиляции), а также рекомендуемо использовать макрос генерации кода возврата IRQ_RETVAL() (рекомендуется выдавать предупреждение в случае прямого возврата, используя оператор return)</ВЕРИФИКАЦИЯ>
<ВЕРТИП>РС/ДВ</ВЕРТИП>
<ПРИМЕЧАНИЯ>РС - для предупреждения
ДВ - проверка допустимости возращаемых значений обработчиков прерываний.</ПРИМЕЧАНИЯ>
<ХАРАКТЕРИСТИКА>ВЫЗОВЫ СИСТЕМНЫХ ФУНКЦИЙ:РЕКОМЕНДУЕМАЯ ЗАМЕНА
КАТЕГОРИЯ:АРХИТЕКТУРА
КАТЕГОРИЯ:СИНТАКСИС</ХАРАКТЕРИСТИКА>
</ПРАВИЛО_ERROR>
</ГРУППА>
<ПРАВИЛО item="n"
line0="{*ID*}"
line1="НАЗНАЧЕНИЕ:"
line2="{*НАЗНАЧЕНИЕ*}"
line3="ПРИМЕР:"
line4="{*ПРИМЕР*}"
line5="ВЕРИФИКАЦИЯ"
line6="{*ВЕРИФИКАЦИЯ*}">
<Имя type="Text" ref="y"></Имя>
<ID type="Text" prefix="ID "></ID>
<НАЗНАЧЕНИЕ type="Text"></НАЗНАЧЕНИЕ>
<ТИП type="Combination" format="ERROR1/ERROR2/ERROR3/WARNING1/WARNING2/WARNING3/RECOMMENDATION" html="y"></ТИП>
<ПРИМЕР type="Text"></ПРИМЕР>
<ВЕРИФИКАЦИЯ type="Text"></ВЕРИФИКАЦИЯ>
<ВЕРТИП type="Text"></ВЕРТИП>
<ПРИМЕЧАНИЯ type="Text"></ПРИМЕЧАНИЯ>
<СОСТОЯНИЕ type="Text"></СОСТОЯНИЕ>
<ХАРАКТЕРИСТИКА type="Text"></ХАРАКТЕРИСТИКА>
</ПРАВИЛО>
</КОРЕНЬ>